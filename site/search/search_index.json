{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mlky","text":"<p>Because it's the only Way.</p>"},{"location":"#what-is-mlky","title":"What is mlky?","text":"<p>mlky is a versatile Python configuration software package designed by data scientists at the Jet Propulsion Laboratory to cater to the needs of research projects and machine learning pipelines. Originally conceived as a collection of utility scripts and functions, mlky has evolved into a comprehensive configuration package that prioritizes flexibility, robustness, and scalability.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Configuration Patching: The core of mlky is the patching structure that enables configuration sections to patch from others. This empowers users to craft intricate configuration setups, overriding keys, subkeys, and updating values as needed.</p> </li> <li> <p>Forgiving or Restrictive: mlky imposes minimal requirements right out of the box. With the custom-built <code>Null</code> class, mlky avoids raising exceptions when pieces of the configuration are absent. This allows developers to focus on developing their code and less on developing their configuration structures. However, mlky also provides the tools for developers to restrict exactly what configurations consist of. The flexibility of your configuration is for you to define!</p> </li> <li> <p>Customizable Restriction: While flexibility is paramount, mlky uniquely provides developers the ability to enforce restrictions on a per-key basis. Error-checking, type-checking, type-coercion, and custom parse functions are supported, enabling fine-grained control over configuration options.</p> </li> <li> <p>TRL Scalability: mlky is designed to assist projects scaling the Technology Readiness Levels (TRL). At low-TRLs, mlky offers its maximum flexibility by providing minimal setup, simple syntax, and forgiving fault tolerance. Once time for a project to mature, mlky assists achieving higher TRLs by providing the framework to set rigid configuration requirements, template generation, and custom error checking.</p> </li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community. If you'd like to contribute to mlky, please follow these steps:</p> <ol> <li>Fork the repository and clone it locally.</li> <li>Create a new branch for your feature or bug fix.</li> <li>Make your changes and ensure tests pass.</li> <li>Commit your changes and push them to your fork.</li> <li>Open a pull request with a detailed description of your changes.</li> </ol>"},{"location":"#license","title":"License","text":"<p>mlky is distributed under the Apache v2.0 License. Feel free to use, modify, and distribute it according to the terms of the license.</p> <p>Explore the power of flexible and robust configuration with mlky, the configuration package built by data scientists, for data scientists. Whether you're working on a small project or a complex system, mlky adapts to your needs and helps you streamline your configuration process.</p>"},{"location":"usage/","title":"Getting Started","text":"<p>mlky is recommended to be installed via pip at this time.</p>"},{"location":"usage/#installation","title":"Installation","text":"<p>You can install mlky using pip:</p> <pre><code>pip install mlky\n</code></pre> <p>Or via Conda:</p> <pre><code>conda install -c jammont mlky\n</code></pre>"},{"location":"usage/#quick-overview","title":"Quick Overview","text":"<p>To get started with mlky, import the <code>Config</code> class and pass it either a yaml file, yaml string, or a dict:</p> <pre><code>&gt;&gt;&gt; from mlky import Config\n# Empty initially\n&gt;&gt;&gt; Config\n&lt;Config . (Attrs=[], Sects=[])&gt;\n# Now initialized\n&gt;&gt;&gt; Config({'A': {'a': 1, 'b': 2}, 'B': {'a': 0, 'c': 3}})\n&lt;Config . (Attrs=[], Sects=['A', 'B'])&gt;\n</code></pre> <p>The <code>Config</code> object supports both dot and dict notation:</p> <pre><code>&gt;&gt;&gt; Config.A\n&lt;Sect .A (Attrs=['a', 'b'], Sects=[])&gt;\n&gt;&gt;&gt; Config['B']\n&lt;Sect .B (Attrs=['a', 'c'], Sects=[])&gt;\n&gt;&gt;&gt; Config.A.a\n1\n&gt;&gt;&gt; Config['B']['a']\n0\n&gt;&gt;&gt; Config['A'].b\n2\n&gt;&gt;&gt; Config.B['c']\n3\n</code></pre> <p>It is also a singleton, though that can be overridden with the <code>local=True</code> parameter:</p> <pre><code>def set_param(key, value, local=False):\n  config = Config(local=local)\n  config[key] = value\n\ndef get_param(key, local=False):\n  config = Config(local=local)\n  return config[key]\n\n&gt;&gt;&gt; set_param('persist', True) # Global\n&gt;&gt;&gt; get_param('persist') # Global\nTrue\n&gt;&gt;&gt; set_param('local', True, local=True)\n&gt;&gt;&gt; get_param('local')\nNull\n&gt;&gt;&gt; get_param('persist', local=True) # Copies global instance\nTrue\n</code></pre> <p>Because it is a singleton, you can also use <code>Config</code> directly instead of a variable as well as use the class across the Python instance:</p> <pre><code># Script 1\nfrom mlky import Config\n\nConfig(a=1, b=2) # initialize somewhere\n</code></pre> <pre><code># Script 2\nfrom mlky import Config\n\nConfig.a == 1\nConfig.b == 2\n</code></pre> <p>Ideally you would want to initialize the <code>Config</code> object at the beginning and then leverage the global instance:</p> <pre><code>from mlky import Config\n\ndef process(item):\n  if Config.param:\n    ...\n\ndef main():\n  for item in Config.process:\n    process(item)\n\nif __name__ == '__main__':\n  Config('/some/config.yaml')\n  main()\n</code></pre>"},{"location":"usage/#experimental-features","title":"Experimental Features","text":"<p>By default, list types are converted to Sect objects. For instance:</p> <pre><code>&gt;&gt;&gt; Config({'key': ['a', 'b', 'c']})\n&gt;&gt;&gt; Config.key\n&lt;Sect .key (Attrs=[0, 1, 2], Sects=[])&gt;\n&gt;&gt;&gt; Config.key[0]\n'a'\n&gt;&gt;&gt; Config.key.toPrimitive() # Will auto detect if it should be a dict or list, in this case a list\n['a', 'b', 'c']\n&gt;&gt;&gt; Config.key.toList() # Explicitly cast to list\n['a', 'b', 'c']\n&gt;&gt;&gt; Config.key.values() # Alternative\n['a', 'b', 'c']\n&gt;&gt;&gt; for i, v in Config.key.items():\n...  print(i, v)\n0 a\n1 b\n2 c\n</code></pre> <p>This behaviour can be disabled by setting <code>Sect._opts.convertListTypes = False</code>:</p> <pre><code>&gt;&gt;&gt; from mlky import Sect\n&gt;&gt;&gt; Sect._opts.convertListTypes = False\n&gt;&gt;&gt; Config({'key': ['a', 'b', 'c']})\n&gt;&gt;&gt; Config.key\n['a', 'b', 'c']\n</code></pre>"},{"location":"usage/#detailed-walkthrough","title":"Detailed Walkthrough","text":"<p>The following will be used as an example:</p> <pre><code>from glob import glob\n\nfrom mlky import Config\n\ndef process(files):\n  for file in files:\n    with open(file, 'r') as f:\n      lines = f.readlines()\n\n    if Config.skip_header:\n      lines = lines[Config.header:]\n\n    ... # Some arbitrary other processing code\n\n    if Config.output:\n      with open(Config.output.file, 'a') as f:\n        f.writelines(lines)\n\nif __name__ == '__main__':\n  parser = argparse.ArgumentParser()\n  parser.add_argument('-c', '--config', required=True)\n  parser.add_argument('-p', '--patch')\n  args = parser.parse_args()\n\n  Config(args.config, args.patch)\n\n  if Config.get('input'):\n    files = glob(f'{Config.input}/*')\n    process(files)\n  else:\n    print('Error: No input provided!')\n</code></pre> <p>Command: <code>python script.py -c /some/config.yml -p sect1&lt;-sect2</code></p> <p>Calling the script with the above command will step through:</p> <ol> <li>Initialize the global <code>Config</code> instance with the file and patch provided     a. That is, <code>sect1</code> in the <code>config.yml</code> will be patched with <code>sect2</code></li> <li>Check if <code>Config.input</code> exists     a. If it is in the Config, return it as-is. If it is not, this will be a <code>Null</code> value which evalutes to <code>False</code></li> <li>Use the value at <code>Config.input</code> to glob some directory</li> <li>Process the collected files</li> <li>For each file, read in the data</li> <li>If <code>Config.skip_header</code> is defined, use the (expected to be an int) value of <code>Config.header</code>     a. It is on the user to ensure proper safeguards are inplace.     b. Multiple possible safeguards include:<ol> <li><code>int(Config.header)</code> to raise an exception if the value cannot be casted to an integer</li> <li><code>Config.get('header', 5)</code> to use a default value if this key is not in the config</li> <li>A definitions file to ensure this key is an int (safest)</li> </ol> </li> <li>Check if <code>Config.output</code> is defined, which is expected to be a Sect</li> <li>Append write data to <code>Config.output.file</code></li> </ol>"},{"location":"usage/#cli","title":"CLI","text":"<p>The following has been created that can be added to your scripts to enable initialization of the <code>Config</code>:</p> <pre><code>import argparse\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)\n\n    parser.add_argument('-c', '--config',   type     = str,\n                                            required = True,\n                                            metavar  = '/path/to/Config.yaml',\n                                            help     = 'Path to a Config.yaml file'\n    )\n    parser.add_argument('-p', '--patch',    nargs    = '?',\n                                            metavar  = 'sect1 ... sectN',\n                                            help     = 'Patch Sects together starting from sect1 to sectN'\n    )\n\n    args = parser.parse_args()\n\n    Config(args.config, args.patch)\n</code></pre> <p>A <code>Click</code> function will be provided at a later time.</p>"},{"location":"api/config/","title":"api/configs/Config","text":"<p>             Bases: <code>Sect</code></p> Source code in <code>mlky/configs/config.py</code> <pre><code>class Config(Sect):\n    def __init__(self, data={}, patch=[], defs={}, debug=-1, validate=True, _raise=True, **kwargs):\n        \"\"\"\n        \"\"\"\n        # Config-specific private variables\n        self.__dict__['_patch'] = patch = self.parsePatch(patch)\n        self.__dict__['_raise'] = _raise\n\n        # If patching, don't apply defs with creation\n        if patch:\n            # Patching the post initialized state is easiest\n            super().__init__(data=data, debug=debug, **kwargs)\n            self.patchSects(patch, inplace=True)\n\n            if defs:\n                # Apply defs post patching\n                self.applyDefinition(defs)\n        else:\n            super().__init__(\n                data  = data,\n                defs  = defs,\n                debug = debug,\n                **kwargs\n            )\n\n        # Always called after initialization in case registered checks need to be re-added\n        funcs.getRegister('config.addChecks')()\n\n        # Reset all Vars to refresh any magic changes that need to happen\n        self.resetVars()\n\n    def __call__(self, data=None, patch=[], defs={}, *, local=False, **kwargs):\n        \"\"\"\n        Enables resetting the global instance Config or create local copies\n        \"\"\"\n        # Changing debug state needs to update before anything else to ensure expected behaviour\n        debug = kwargs.get('debug')\n        if debug is not None:\n            if isinstance(debug, int):\n                debug = range(0, debug+1)\n            self.__dict__['_dbug'] = set(debug)\n\n        # Backwards compatible config = Config()\n        if data is None:\n            if local is True:\n                self._log(1, '__call__', 'No data, local True, creating deep copy of global instance')\n                self = self.deepCopy()\n                self._log(1, '__call__', 'Returning deep copy')\n            else:\n                self._log(1, '__call__', 'No data, local False, returning global instance')\n            return self\n\n        # Local creates a new instance\n        if local:\n            self._log(1, '__call__', 'Creating new local instance of Config using different data')\n            self = type(self)(data, patch, defs, **kwargs)\n            self._log(1, '__call__', 'Returning new, different local instance')\n        else:\n            # Otherwise update the global instance\n            self._log(1, '__call__', 'Reinitializing the global instance using new data')\n            self.__init__(data, patch, defs, **kwargs)\n            self._log(1, '__call__', 'The global instance has been reinitialized')\n        return self\n\n    def patchSects(self, keys, inplace=False):\n        \"\"\"\n        Patches child Sects in order given\n\n        Parameters\n        ----------\n        keys: list\n            Patch keys list in order\n        inplace: bool, default=False\n            Auto set the Config `_sect` to the patched Sect\n\n        Returns\n        -------\n        self: mlky.Config or new: mlky.Sect\n            If inplace, returns self with newly set _sect. Otherwise return the\n            newly patched Sect\n        \"\"\"\n        self._log(0, 'patchSects', f'Patching using: {keys}')\n\n        new = Sect(debug=self._dbug)\n        for key in keys:\n            self._log(0, 'patchSects', f'Patching with [{key!r}]')\n            if key in self:\n                data = self.get(key, var=True)\n                if isinstance(data, Sect):\n                    new |= data\n                else:\n                    Logger.error(f'Key [{key!r}] is not a Sect, it is type {type(data)}')\n            else:\n                Logger.error(f'Key [{key!r}] is not in this Config')\n\n        if inplace:\n            self._log(0, 'patchSects', f'Setting new patched Sect inplace')\n            self.__dict__['_sect'] = NullDict(new.toPrimitive(deep=False, var=True))\n            new = self\n\n        return new\n\n    def resetSects(self, keys=None, **kwargs):\n        \"\"\"\n        Resets to the last initialized state. This is a hard reset, any changes\n        to the config since last initialization will be lost. This is because\n        this just recreates the Config using the internal `_data` which was the\n        last input to Config. Changes to the Config afterwards is done to the\n        internal `_sect` and won't be reflected in `_data`.\n\n        Parameters\n        ----------\n        keys: list, default=None\n            Patch keys list. `None` defaults to the last used. Empty list `[]`\n            will remove patching altogether\n\n        Returns\n        -------\n        Config: mlky.Config\n            Reset Config instance, either global or local\n        \"\"\"\n        self._log(0, 'resetSects', 'This is a hard reset, be careful')\n        parms = dict(\n            data  = self._data,\n            patch = self._patch if keys is None else keys,\n            defs  = self._defs or {}\n        )\n        return self(**(parms | kwargs))\n\n    @staticmethod\n    def parsePatch(patch):\n        \"\"\"\n        Supports different patching syntax styles:\n            str : \"key1&lt;-key2&lt;-keyN\"\n            list: [key1, key2, keyN]\n        \"\"\"\n        if isinstance(patch, str):\n            return patch.split('&lt;-')\n        return patch\n\n    @staticmethod\n    def addChecks():\n        \"\"\"\n        Simply calls funcs.getRegister('config.addChecks')()\n        \"\"\"\n        funcs.getRegister('config.addChecks')()\n</code></pre>"},{"location":"api/config/#mlky.configs.config.Config.__call__","title":"<code>__call__(data=None, patch=[], defs={}, *, local=False, **kwargs)</code>","text":"<p>Enables resetting the global instance Config or create local copies</p> Source code in <code>mlky/configs/config.py</code> <pre><code>def __call__(self, data=None, patch=[], defs={}, *, local=False, **kwargs):\n    \"\"\"\n    Enables resetting the global instance Config or create local copies\n    \"\"\"\n    # Changing debug state needs to update before anything else to ensure expected behaviour\n    debug = kwargs.get('debug')\n    if debug is not None:\n        if isinstance(debug, int):\n            debug = range(0, debug+1)\n        self.__dict__['_dbug'] = set(debug)\n\n    # Backwards compatible config = Config()\n    if data is None:\n        if local is True:\n            self._log(1, '__call__', 'No data, local True, creating deep copy of global instance')\n            self = self.deepCopy()\n            self._log(1, '__call__', 'Returning deep copy')\n        else:\n            self._log(1, '__call__', 'No data, local False, returning global instance')\n        return self\n\n    # Local creates a new instance\n    if local:\n        self._log(1, '__call__', 'Creating new local instance of Config using different data')\n        self = type(self)(data, patch, defs, **kwargs)\n        self._log(1, '__call__', 'Returning new, different local instance')\n    else:\n        # Otherwise update the global instance\n        self._log(1, '__call__', 'Reinitializing the global instance using new data')\n        self.__init__(data, patch, defs, **kwargs)\n        self._log(1, '__call__', 'The global instance has been reinitialized')\n    return self\n</code></pre>"},{"location":"api/config/#mlky.configs.config.Config.__init__","title":"<code>__init__(data={}, patch=[], defs={}, debug=-1, validate=True, _raise=True, **kwargs)</code>","text":"Source code in <code>mlky/configs/config.py</code> <pre><code>def __init__(self, data={}, patch=[], defs={}, debug=-1, validate=True, _raise=True, **kwargs):\n    \"\"\"\n    \"\"\"\n    # Config-specific private variables\n    self.__dict__['_patch'] = patch = self.parsePatch(patch)\n    self.__dict__['_raise'] = _raise\n\n    # If patching, don't apply defs with creation\n    if patch:\n        # Patching the post initialized state is easiest\n        super().__init__(data=data, debug=debug, **kwargs)\n        self.patchSects(patch, inplace=True)\n\n        if defs:\n            # Apply defs post patching\n            self.applyDefinition(defs)\n    else:\n        super().__init__(\n            data  = data,\n            defs  = defs,\n            debug = debug,\n            **kwargs\n        )\n\n    # Always called after initialization in case registered checks need to be re-added\n    funcs.getRegister('config.addChecks')()\n\n    # Reset all Vars to refresh any magic changes that need to happen\n    self.resetVars()\n</code></pre>"},{"location":"api/config/#mlky.configs.config.Config.addChecks","title":"<code>addChecks()</code>  <code>staticmethod</code>","text":"<p>Simply calls funcs.getRegister('config.addChecks')()</p> Source code in <code>mlky/configs/config.py</code> <pre><code>@staticmethod\ndef addChecks():\n    \"\"\"\n    Simply calls funcs.getRegister('config.addChecks')()\n    \"\"\"\n    funcs.getRegister('config.addChecks')()\n</code></pre>"},{"location":"api/config/#mlky.configs.config.Config.parsePatch","title":"<code>parsePatch(patch)</code>  <code>staticmethod</code>","text":"Supports different patching syntax styles <p>str : \"key1&lt;-key2&lt;-keyN\" list: [key1, key2, keyN]</p> Source code in <code>mlky/configs/config.py</code> <pre><code>@staticmethod\ndef parsePatch(patch):\n    \"\"\"\n    Supports different patching syntax styles:\n        str : \"key1&lt;-key2&lt;-keyN\"\n        list: [key1, key2, keyN]\n    \"\"\"\n    if isinstance(patch, str):\n        return patch.split('&lt;-')\n    return patch\n</code></pre>"},{"location":"api/config/#mlky.configs.config.Config.patchSects","title":"<code>patchSects(keys, inplace=False)</code>","text":"<p>Patches child Sects in order given</p>"},{"location":"api/config/#mlky.configs.config.Config.patchSects--parameters","title":"Parameters","text":"<p>keys: list     Patch keys list in order inplace: bool, default=False     Auto set the Config <code>_sect</code> to the patched Sect</p>"},{"location":"api/config/#mlky.configs.config.Config.patchSects--returns","title":"Returns","text":"<p>self: mlky.Config or new: mlky.Sect     If inplace, returns self with newly set _sect. Otherwise return the     newly patched Sect</p> Source code in <code>mlky/configs/config.py</code> <pre><code>def patchSects(self, keys, inplace=False):\n    \"\"\"\n    Patches child Sects in order given\n\n    Parameters\n    ----------\n    keys: list\n        Patch keys list in order\n    inplace: bool, default=False\n        Auto set the Config `_sect` to the patched Sect\n\n    Returns\n    -------\n    self: mlky.Config or new: mlky.Sect\n        If inplace, returns self with newly set _sect. Otherwise return the\n        newly patched Sect\n    \"\"\"\n    self._log(0, 'patchSects', f'Patching using: {keys}')\n\n    new = Sect(debug=self._dbug)\n    for key in keys:\n        self._log(0, 'patchSects', f'Patching with [{key!r}]')\n        if key in self:\n            data = self.get(key, var=True)\n            if isinstance(data, Sect):\n                new |= data\n            else:\n                Logger.error(f'Key [{key!r}] is not a Sect, it is type {type(data)}')\n        else:\n            Logger.error(f'Key [{key!r}] is not in this Config')\n\n    if inplace:\n        self._log(0, 'patchSects', f'Setting new patched Sect inplace')\n        self.__dict__['_sect'] = NullDict(new.toPrimitive(deep=False, var=True))\n        new = self\n\n    return new\n</code></pre>"},{"location":"api/config/#mlky.configs.config.Config.resetSects","title":"<code>resetSects(keys=None, **kwargs)</code>","text":"<p>Resets to the last initialized state. This is a hard reset, any changes to the config since last initialization will be lost. This is because this just recreates the Config using the internal <code>_data</code> which was the last input to Config. Changes to the Config afterwards is done to the internal <code>_sect</code> and won't be reflected in <code>_data</code>.</p>"},{"location":"api/config/#mlky.configs.config.Config.resetSects--parameters","title":"Parameters","text":"<p>keys: list, default=None     Patch keys list. <code>None</code> defaults to the last used. Empty list <code>[]</code>     will remove patching altogether</p>"},{"location":"api/config/#mlky.configs.config.Config.resetSects--returns","title":"Returns","text":"<p>Config: mlky.Config     Reset Config instance, either global or local</p> Source code in <code>mlky/configs/config.py</code> <pre><code>def resetSects(self, keys=None, **kwargs):\n    \"\"\"\n    Resets to the last initialized state. This is a hard reset, any changes\n    to the config since last initialization will be lost. This is because\n    this just recreates the Config using the internal `_data` which was the\n    last input to Config. Changes to the Config afterwards is done to the\n    internal `_sect` and won't be reflected in `_data`.\n\n    Parameters\n    ----------\n    keys: list, default=None\n        Patch keys list. `None` defaults to the last used. Empty list `[]`\n        will remove patching altogether\n\n    Returns\n    -------\n    Config: mlky.Config\n        Reset Config instance, either global or local\n    \"\"\"\n    self._log(0, 'resetSects', 'This is a hard reset, be careful')\n    parms = dict(\n        data  = self._data,\n        patch = self._patch if keys is None else keys,\n        defs  = self._defs or {}\n    )\n    return self(**(parms | kwargs))\n</code></pre>"},{"location":"api/formatters/","title":"api/utils/formatters","text":"<p>Pretty printers</p>"},{"location":"api/formatters/#mlky.utils.formatters.printTable","title":"<code>printTable(iterable, enum=False, delimiter='=', offset=1, prepend='', print=print, columns={}, _i=0)</code>","text":"<p>Parameters can be set on a per column basis using the columns parameter. This is a dictionary of column indices as keys and the parameters for that column as the value.</p>"},{"location":"api/formatters/#mlky.utils.formatters.printTable--parameters","title":"Parameters","text":"<p>iterable: iterable     Any iterable consisting of subscriptable iterables of strings enum: bool, default=False     Whether to include enumeration of the items delimiter: str, default='='     The symbol to use between the key and the value offset: int, default=1     Space between the key and the delimiter: {key}{offset}{delimiter}     Defaults to 1, eg: \"key =\" prepend: str, default=''     Any string to prepend to each line print: func, default=print     The print function to use. Allows using custom function instead of Python's normal print columns: dict, default={}     Arguments for each column. Only the delimiter and offset may be different     between columns. The keys for this are the column number starting from 0 _i: int, default=0     Which column is being formatted. Used to retrieve column-specific arguments</p>"},{"location":"api/formatters/#mlky.utils.formatters.printTable--returns","title":"Returns","text":"<p>formatted: list</p> Source code in <code>mlky/utils/formatters.py</code> <pre><code>def printTable(iterable, enum=False, delimiter='=', offset=1, prepend='', print=print, columns={}, _i=0):\n    \"\"\"\n    Parameters can be set on a per column basis using the columns parameter. This is a\n    dictionary of column indices as keys and the parameters for that column as the\n    value.\n\n    Parameters\n    ----------\n    iterable: iterable\n        Any iterable consisting of subscriptable iterables of strings\n    enum: bool, default=False\n        Whether to include enumeration of the items\n    delimiter: str, default='='\n        The symbol to use between the key and the value\n    offset: int, default=1\n        Space between the key and the delimiter: {key}{offset}{delimiter}\n        Defaults to 1, eg: \"key =\"\n    prepend: str, default=''\n        Any string to prepend to each line\n    print: func, default=print\n        The print function to use. Allows using custom function instead of Python's normal print\n    columns: dict, default={}\n        Arguments for each column. Only the delimiter and offset may be different\n        between columns. The keys for this are the column number starting from 0\n    _i: int, default=0\n        Which column is being formatted. Used to retrieve column-specific arguments\n\n    Returns\n    -------\n    formatted: list\n    \"\"\"\n    # Retrieve the parameters for this column\n    args      = columns.get(_i, {})\n    delimiter = args.get('delimiter', delimiter)\n    offset    = args.get('offset'   , offset   )\n\n    # Left and right side of the delimiter for this column\n    left  = []\n    right = []\n    for item in iterable:\n        if len(item) &gt; 1:\n            left.append(str(item[0]))\n            right.append(str(item[1]))\n\n    if not left:\n        return []\n\n    padding   = max([0, max(map(len, left))]) + offset\n    formatter = prepend\n    if enum:\n        formatter += '{i:' + f'{len(str(len(iterable)))}' + '}: '\n    formatter += '{left:'+ str(padding) + '}' + delimiter + ' {right}'\n\n    i = 0\n    formatted = []\n    for item in iterable:\n        if len(item) &gt; 1:\n            string = formatter.format(i=i, left=left[i], right=right[i])\n            if len(item) &gt; 2:\n                formatted.append((string, *item[2:]))\n            else:\n                formatted.append((string, ))\n            i += 1\n        else:\n            formatted.append(item)\n\n    # Check if there are any more columns to format\n    if any([len(item) &gt; 1 for item in formatted]):\n        # Only delimiter and offset are carried forward, other parameters disabled\n        formatted = printTable(formatted,\n            delimiter = delimiter,\n            offset    = offset,\n            enum      = False,\n            prepend   = '',\n            print     = None,\n            columns   = columns,\n            _i        = _i + 1\n        )\n\n    # Reduce from [(str,), (str,), ...] to [str, str, ...]\n    if _i == 0:\n        formatted = [item for [item] in formatted]\n\n    # Print is only set on the first call\n    if print:\n        for item in formatted:\n            print(item)\n\n    return formatted\n</code></pre>"},{"location":"api/formatters/#mlky.utils.formatters.simpleTable","title":"<code>simpleTable(iterable, enum=False, delimiter='=', offset=1, prepend='', print=print)</code>","text":"<p>Pretty prints an iterable in the form {key} = {value} such that the delimiter (=) aligns on each line</p>"},{"location":"api/formatters/#mlky.utils.formatters.simpleTable--parameters","title":"Parameters","text":"<p>iterable: iterable     Any iterable with a .items() function enum: bool, default = False     Whether to include enumeration of the items delimiter, default = '='     The symbol to use between the key and the value offset: int, default = 1     Space between the key and the delimiter: {key}{offset}{delimiter}     Defaults to 1, eg: \"key =\" prepend: str, default = ''     Any string to prepend to each line print: func, default = print     The print function to use. Allows using custom function instead of Python's normal print</p> Source code in <code>mlky/utils/formatters.py</code> <pre><code>def simpleTable(iterable, enum=False, delimiter='=', offset=1, prepend='', print=print):\n    \"\"\"\n    Pretty prints an iterable in the form {key} = {value} such that the delimiter (=)\n    aligns on each line\n\n    Parameters\n    ----------\n    iterable: iterable\n        Any iterable with a .items() function\n    enum: bool, default = False\n        Whether to include enumeration of the items\n    delimiter, default = '='\n        The symbol to use between the key and the value\n    offset: int, default = 1\n        Space between the key and the delimiter: {key}{offset}{delimiter}\n        Defaults to 1, eg: \"key =\"\n    prepend: str, default = ''\n        Any string to prepend to each line\n    print: func, default = print\n        The print function to use. Allows using custom function instead of Python's normal print\n    \"\"\"\n    if hasattr(iterable, 'items'):\n        pad   = len(max(iterable.keys(), key=len))\n        items = iterable.items()\n    else:\n        assert len(iterable) &gt; 0, 'Iterable must not be empty'\n        assert all([len(item) == 2 for item in iterable]), 'Iterable must contain iterables of length 2'\n        pad   = len(max(iterable, key=lambda v: len(v[0])))\n        items = iterable\n\n    # Determine how much padding between the key and delimiter\n    pad = max([1, pad]) + offset\n\n    # Build the formatted string\n    fmt = prepend\n    if enum:\n        fmt += '- {i:' + f'{len(str(len(iterable)))}' + '}: '\n    fmt += '{key:'+ str(pad) + '}' + delimiter + ' {value}'\n\n    # Create the formatted list\n    fmt_list = []\n    for i, (key, value) in enumerate(items):\n        string = fmt.format(i=i, key=key, value=value)\n        fmt_list.append(string)\n\n    for string in fmt_list:\n        print(string)\n\n    return fmt_list\n</code></pre>"},{"location":"api/funcs/","title":"api/configs/funcs","text":""},{"location":"api/funcs/#mlky.configs.funcs.ErrorsDict","title":"<code>ErrorsDict</code>","text":"<p>             Bases: <code>dict</code></p> <p>Assists the Sect and Var .validate() functions by enabling an easy way to clean up the final error report dict for easier parsing. This will also assist in resolving return type issues with custom functions by enforcing their return types to only be strings or lists.</p> Source code in <code>mlky/configs/funcs.py</code> <pre><code>class ErrorsDict(dict):\n    \"\"\"\n    Assists the Sect and Var .validate() functions by enabling an easy way to\n    clean up the final error report dict for easier parsing. This will also\n    assist in resolving return type issues with custom functions by enforcing\n    their return types to only be strings or lists.\n    \"\"\"\n    def reduce(self):\n        reduced = ErrorsDict()\n        for key, val in self.items():\n            if isinstance(val, ErrorsDict):\n                new = val.reduce()\n                if new:\n                    reduced[key] = new\n            elif isinstance(val, (str, list)):\n                reduced[key] = val\n        return reduced\n</code></pre>"},{"location":"api/funcs/#mlky.configs.funcs.getRegister","title":"<code>getRegister(key)</code>","text":"<p>Retrieves a function from the registers list</p> Source code in <code>mlky/configs/funcs.py</code> <pre><code>def getRegister(key):\n    \"\"\"\n    Retrieves a function from the registers list\n    \"\"\"\n    if key not in Funcs:\n        # Magic functions initialize at the end of mlky, don't report an error if these don't exist yet\n        if not key.startswith('config.'):\n            Logger.error(f'The following key is not a registered function, returning Null which may have unintended consequences: {key!r}')\n        return Null\n    return Funcs[key]\n</code></pre>"},{"location":"api/funcs/#mlky.configs.funcs.register","title":"<code>register(key='', name=None, regex=False, **kwargs)</code>","text":"<p>Registers a function with mlky to be used either in a definitions file or assigned directly as a check for a given key</p> Source code in <code>mlky/configs/funcs.py</code> <pre><code>def register(key='', name=None, regex=False, **kwargs):\n    \"\"\"\n    Registers a function with mlky to be used either in a definitions file or\n    assigned directly as a check for a given key\n    \"\"\"\n    def wrap(func):\n        \"\"\"\n        Wraps the registered function\n        \"\"\"\n        def protect(*args, **kwargs):\n            \"\"\"\n            Protects from exceptions as well as enables the original `func` to\n            be directly callable\n            \"\"\"\n            try:\n                return func(*args, **kwargs)\n            except Exception as e:\n                Logger.exception(f'Register {name!r} raised an exception:')\n                Logger.warning('Returning the exception message. This may cause unintended behaviour.')\n                return str(e)\n\n        # Either the function name or an assigned one\n        nonlocal name\n        name = name or func.__name__\n\n        if name in Funcs:\n            Logger.warning(f'Function is already registered and will be replaced: {name!r}')\n\n        # This check will be assigned to a specific key\n        if key.startswith('.'):\n            Checks.setdefault(key, []).append(name)\n\n        # Register the function\n        Funcs[name] = protect\n        Logger.debug(f'Registered function {name!r}')\n\n        return protect\n\n    return wrap\n</code></pre>"},{"location":"api/io/","title":"api/utils/io","text":"<p>IO related utilities</p>"},{"location":"api/io/#mlky.utils.io.load_pkl","title":"<code>load_pkl(file)</code>","text":"<p>Loads data from a pickle</p>"},{"location":"api/io/#mlky.utils.io.load_pkl--parameters","title":"Parameters","text":"<p>file : str     Path to a Python pickle file to load</p>"},{"location":"api/io/#mlky.utils.io.load_pkl--returns","title":"Returns","text":"<p>any     The data object loaded from the pickle file</p> Source code in <code>mlky/utils/io.py</code> <pre><code>def load_pkl(file):\n    \"\"\"\n    Loads data from a pickle\n\n    Parameters\n    ----------\n    file : str\n        Path to a Python pickle file to load\n\n    Returns\n    -------\n    any\n        The data object loaded from the pickle file\n    \"\"\"\n    return pickle.load(open(file, 'rb'))\n</code></pre>"},{"location":"api/io/#mlky.utils.io.load_string","title":"<code>load_string(string)</code>","text":"<p>Loads a dict from a string</p> Source code in <code>mlky/utils/io.py</code> <pre><code>def load_string(string):\n    \"\"\"\n    Loads a dict from a string\n    \"\"\"\n    # File case\n    if os.path.exists(string):\n        with open(string, 'r') as file:\n            data = yaml.load(file, Loader=yaml.FullLoader)\n    # Raw string case\n    else:\n        data = yaml.load(string, Loader=yaml.FullLoader)\n\n    return data\n</code></pre>"},{"location":"api/io/#mlky.utils.io.mkdir","title":"<code>mkdir(path)</code>","text":"<p>Attempts to create directories for a given path</p> Source code in <code>mlky/utils/io.py</code> <pre><code>def mkdir(path):\n    \"\"\"\n    Attempts to create directories for a given path\n    \"\"\"\n    # Make sure this is a directory path\n    path, _ = os.path.split(path)\n\n    # Split into parts to reconstruct\n    split = path.split('/')\n\n    # Now reconstruct the path one step at a time and ensure the directory exists\n    for i in range(2, len(split)+1):\n        dir = '/'.join(split[:i])\n        if not os.path.exists(dir):\n            try:\n                os.mkdir(dir, mode=0o771)\n            except Exception as e:\n                Logger.exception(f'Failed to create directory {dir}')\n                raise e\n</code></pre>"},{"location":"api/io/#mlky.utils.io.save_pkl","title":"<code>save_pkl(data, output)</code>","text":"<p>Saves data to a file via pickle</p>"},{"location":"api/io/#mlky.utils.io.save_pkl--parameters","title":"Parameters","text":"<p>data: any     Any pickleable object output : str     Path to a file to dump the data to via pickle</p> Source code in <code>mlky/utils/io.py</code> <pre><code>def save_pkl(data, output):\n    \"\"\"\n    Saves data to a file via pickle\n\n    Parameters\n    ----------\n    data: any\n        Any pickleable object\n    output : str\n        Path to a file to dump the data to via pickle\n    \"\"\"\n    mkdir(output)\n    with open(output, 'wb') as file:\n        pickle.dump(data, file)\n</code></pre>"},{"location":"api/magics/","title":"api/configs/magics","text":"<p>Handles the magics syntax mlky defines</p>"},{"location":"api/magics/#mlky.configs.magics.addChecks","title":"<code>addChecks()</code>","text":"<p>Adds checks that were assigned by a registered function to the Config</p> Source code in <code>mlky/configs/magics.py</code> <pre><code>@register(name='config.addChecks')\ndef addChecks():\n    \"\"\"\n    Adds checks that were assigned by a registered function to the Config\n    \"\"\"\n    Config._log(0, 'addChecks', 'Adding checks to Config')\n    for key, checks in funcs.Checks.items():\n        lvls = key.split('.')[1:]\n\n        # Find the key of interest\n        this = Config\n        for lvl in lvls:\n            this = this.get(lvl, Null, var=True)\n\n        # Assign the check if the key exists\n        if this:\n            this._f.checks += checks\n            Logger.debug(f'\u2514 {this}._f.checks += {checks}')\n</code></pre>"},{"location":"api/magics/#mlky.configs.magics.replace","title":"<code>replace(value, instance=None)</code>","text":"<p>Replaces format signals in strings with values from the config relative to its inheritance structure.</p>"},{"location":"api/magics/#mlky.configs.magics.replace--parameters","title":"Parameters","text":"<p>value: str     Matches roughly to ${config.*} in the string and replaces them with the     corrosponding config value. See notes the regex for accuracy. instance: Sect, defaults=None     Instance to use for value lookups. Defaults to the global instance</p>"},{"location":"api/magics/#mlky.configs.magics.replace--returns","title":"Returns","text":"<p>string: str     Same string but with the values replaced.</p>"},{"location":"api/magics/#mlky.configs.magics.replace--notes","title":"Notes","text":"<p>The regex used for matching is r\"\\${([.\\$].*?)}\". This will match to any string starting with <code>.</code> or <code>$</code> wrapped by <code>${}</code>. Reasons to only match starting with specific keys is to:     - <code>.</code> - Config value lookup     - <code>$</code> - Environment variable lookup</p> <p>Config references must be relative to the inheritance structure. With inheritance, the top level sections do not exist. Without inheritance, they do. Examples:</p> Source code in <code>mlky/configs/magics.py</code> <pre><code>@register(name='config.replace')\ndef replace(value, instance=None):\n    \"\"\"\n    Replaces format signals in strings with values from the config relative to\n    its inheritance structure.\n\n    Parameters\n    ----------\n    value: str\n        Matches roughly to ${config.*} in the string and replaces them with the\n        corrosponding config value. See notes the regex for accuracy.\n    instance: Sect, defaults=None\n        Instance to use for value lookups. Defaults to the global instance\n\n    Returns\n    -------\n    string: str\n        Same string but with the values replaced.\n\n    Notes\n    -----\n    The regex used for matching is r\"\\${([\\.\\$].*?)}\". This will match to any\n    string starting with `.` or `$` wrapped by `${}`. Reasons to only match\n    starting with specific keys is to:\n        - `.` - Config value lookup\n        - `$` - Environment variable lookup\n\n    Config references must be relative to the inheritance structure. With\n    inheritance, the top level sections do not exist. Without inheritance, they\n    do. Examples:\n\n    &gt;&gt;&gt; # Without inheritance\n    &gt;&gt;&gt; config = Config('''\n    default:\n        path: /abc\n        vars:\n            x: 1\n            y: 2\n    foo:\n        file: ${.default.path}/${.default.vars.x}/${.default.vars.y}\n    ''')\n    &gt;&gt;&gt; replace(config.foo.file)\n    '/abc/1/2'\n\n    &gt;&gt;&gt; # With inheritance\n    &gt;&gt;&gt; config = Config('''\n    default:\n        path: /abc\n        vars:\n            x: 1\n            y: 2\n    foo:\n        file: ${.path}/${.vars.x}/${.vars.y}\n    ''', 'default&lt;-foo')\n    &gt;&gt;&gt; replace(config.file)\n    '/abc/1/2'\n    \"\"\"\n    if isinstance(value, str):\n        # Special case for special Null syntax\n        if value == '\\\\':\n            return Null\n\n        matches = re.findall(r\"\\${([\\.\\$\\!].*?)}\", value)\n\n        for match in matches:\n            # Config lookup case\n            if match.startswith('.'):\n                keys = match.split('.')\n\n                if len(keys) &lt; 2:\n                    Logger.error(f'Keys path provided is invalid, returning without replacement: {keys!r}')\n                    return value\n\n                data = instance or Config\n                for key in keys[1:]:\n                    data = data.__getattr__(key)\n\n                if isinstance(data, Null):\n                    Logger.warning(f'Lookup({match}) returned Null. This may not be expected and may cause issues.')\n\n            # Environment variable lookup case\n            elif match.startswith('$'):\n                data = funcs.getRegister('get_env')(match[1:])\n\n            # Lookup custom function case\n            elif match.startswith('?'):\n                data = funcs.getRegister(match[1:])\n\n            # Data lookup case\n            elif match.startswith('!'):\n                return funcs.getRegister(match[1:])\n\n            else:\n                Logger.warning(f'Replacement matched to string but no valid starter token provided: {match!r}')\n\n            value = value.replace('${'+ match +'}', str(data))\n\n    return value\n</code></pre>"},{"location":"api/magics/#mlky.configs.magics.replace--without-inheritance","title":"Without inheritance","text":"<p>config = Config(''' default:     path: /abc     vars:         x: 1         y: 2 foo:     file: ${.default.path}/${.default.vars.x}/${.default.vars.y} ''') replace(config.foo.file) '/abc/1/2'</p>"},{"location":"api/magics/#mlky.configs.magics.replace--with-inheritance","title":"With inheritance","text":"<p>config = Config(''' default:     path: /abc     vars:         x: 1         y: 2 foo:     file: ${.path}/${.vars.x}/${.vars.y} ''', 'default&lt;-foo') replace(config.file) '/abc/1/2'</p>"},{"location":"api/prettyslice/","title":"api/utils/prettyslice","text":"<p>Pretty prints slice objects</p>"},{"location":"api/prettyslice/#mlky.utils.prettyslice.PrettySlice","title":"<code>PrettySlice</code>","text":"<p>Simply pretty prints slices as '{start}:{stop}'</p> <p>Acts/is a slice object otherwise</p> Source code in <code>mlky/utils/prettyslice.py</code> <pre><code>class PrettySlice:\n    \"\"\"\n    Simply pretty prints slices as '{start}:{stop}'\n\n    Acts/is a slice object otherwise\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self._slice = slice(*args, **kwargs)\n\n    def __getattribute__(self, key):\n        if key == '_slice':\n            return super().__getattribute__('_slice')\n        return getattr(self._slice, key)\n\n    def __repr__(self):\n        r = ':'\n        if self.start is not None:\n            r = str(self.start) + r\n        if self.stop is not None:\n            r += str(self.stop)\n        return r\n</code></pre>"},{"location":"api/sect/","title":"api/configs/Sect","text":"Source code in <code>mlky/configs/sect.py</code> <pre><code>class Sect:\n    # Default values for when a subclass isn't fully initialized\n    _name = \"\"\n    _sect = NullDict()\n    _defs = {}\n    _dbug = -1\n    _prnt = Null\n    _type = 'Dict'\n    _chks = []\n\n    # Options to control the behaviour of the Sect object for all Sect objects\n    _opts = NullDict(\n        # TODO: (Doc this better) Not converting list types will prevent the ability to patch them, values for these keys will simply be replaced on patch\n        convertListTypes = True,\n        convertItems     = True,\n        VarsReplaceInit  = True\n    )\n\n    # Class defaults, change these manually via Sect.__dict__[key] = ...\n    _repr = 10 # __repr__ limiter to prevent prints being obnoxious\n\n    def __init__(self,\n        data    = {},\n        name    = \"\",\n        defs    = {},\n        missing = False,\n        debug   = -1,\n        parent  = Null,\n        _opts   = {},\n        **kwargs\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        debug: int or list, defaults=-1\n            Controls the verbosity of the class. Higher values is increased\n            verbosity. Current levels:\n                -1: Default, disables debug messages\n                 0: Non-private functions (non-underscore named functions)\n                 1: Private functions (single underscores)\n                 2: _setdata()\n                 3: getattr, get(), items()\n                 4: Repr, very spammy\n            If passed as a list of ints, will only enable those levels.\n            If the list is comprised of strings, any function names in this list\n            will be enabled\n        _opts: dict, defaults={}\n            Override options for this Sect and its children only. This will also detach\n            this Sect from the global options, so those changes will not propogate\n\n        Notes\n        -----\n        Initialization support:\n        - From Sect     = Sect(Sect({...}))\n        - From dict     = Sect({'a': 1, 'b': 2})\n        - From list     = Sect(['a', 'b'])\n        - From tuple    = Sect(('a', 'b'))\n        - As a function = Sect(a=1, b=2)\n        \"\"\"\n        if isinstance(debug, int):\n            debug = range(0, debug+1)\n\n        # Override the options for this Sect if given\n        if _opts:\n            self.__dict__['_opts'] = NullDict(self._opts | _opts)\n\n        # Parse the input data from a supported type\n        data = self.loadDict(data)\n\n        self.__dict__['_name'] = name\n        self.__dict__['_data'] = data\n        self.__dict__['_miss'] = missing\n        self.__dict__['_dbug'] = set(debug)\n        self.__dict__['_prnt'] = parent\n        self.__dict__['_chks'] = []\n        self.__dict__['_sect'] = NullDict()\n\n        if isinstance(data, dict):\n            # if the input data is a dict, combine with kwargs to allow mix inputs eg. Sect({'a': 1}, b=2)\n            for key, value in (kwargs | data).items():\n                self._setdata(key, value,\n                    defs = defs.get(f'.{key}', {})\n                )\n\n        elif isinstance(data, (list, tuple)):\n            # Flag that this is a list-type Sect to change some downstream behaviours\n            self.__dict__['_type'] = 'List'\n            for i, value in enumerate(data):\n                self._setdata(i, value, defs=defs)\n\n        elif isinstance(data, Sect):\n            super().__setattr__('__dict__', data.deepCopy().__dict__)\n\n        if defs:\n            self.applyDefinition(defs)\n\n    def __call__(self, other, inplace=True):\n        \"\"\"\n        Enables patching via call, Sect(other)\n        \"\"\"\n        if isinstance(other, (type(self), dict)):\n            return self._patch(other, inplace=inplace)\n        raise TypeError(f'mlky.Sect can only be patched using other dicts or Sects')\n\n    def __eq__(self, other):\n        if self._dbug:\n            self._log(1, '__eq__', f'Comparing to type: {type(other)} = {other!r}')\n\n        # Convert this to its primitive type for safer comparisons\n        data = self.toPrimitive()\n\n        # Same if compared to another Sect\n        if isinstance(other, (type(self), Sect)):\n            other = other.toPrimitive()\n\n        return data == other\n\n    def __or__(self, other):\n        \"\"\"\n        Enables patching using the | operator\n\n        Notes\n        -----\n        To enable subclass patching behaviour with both itself and this class,\n        check if isinstance of itself and Sect\n        \"\"\"\n        if isinstance(other, (type(self), Sect, dict)):\n            return self._patch(other, inplace=False)\n        raise TypeError(f'mlky.Sect can only use operator | (or) with other dicts or Sects')\n\n    def __lt__(self, other):\n        \"\"\"\n        Enables patching using the &lt; operator\n\n        Notes\n        -----\n        To enable subclass patching behaviour with both itself and this class,\n        check if isinstance of itself and Sect\n        \"\"\"\n        if isinstance(other, (type(self), Sect, dict)):\n            return self._patch(other, inplace=False)\n        raise TypeError(f'mlky.Sect can only use operator &lt; (lt) with other dicts or Sects')\n\n    def __setattr__(self, key, value):\n        self._setdata(key, value)\n\n    def __setitem__(self, key, value):\n        self._setdata(key, value)\n\n    def __getattr__(self, key, var=False, default=True):\n        \"\"\"\n        Interfaces with _sect to retrieve the Var and Sect child objects\n        _sect should always be a NullDict\n\n        Parameters are accessible via the .get() method\n\n        Parameters\n        ----------\n        key: str\n            Attribute name to look up\n        var: bool, defaults=False\n            Return the item as a Var\n        default: bool, defaults=True\n            Return a Var's default value if available\n        \"\"\"\n        val = self._sect[key]\n\n        if isinstance(val, Var):\n            if var:\n                self._log(3, '__getattr__', f'[{key!r}] Returning as Var: {val}')\n                return val\n\n            if default and val.value is Null:\n                self._log(3, '__getattr__', f'[{key!r}] Returning {val}.default')\n                return val.default\n\n            self._log(3, '__getattr__', f'[{key!r}] Returning {val}.value')\n            return val.value\n\n        if not isinstance(val, (Sect, NullType)):\n            self._log('e', '__getattr__', f'Item of _sect is not a Var, Sect, or Null type: [{key!r}] = {type(val)} {val}')\n\n        self._log(3, '__getattr__', f'[{key!r}] Returning value: {val!r}')\n        return val\n\n    def __getitem__(self, key):\n        return self.__getattr__(key)\n\n    def __contains__(self, key):\n        return key in self._sect\n\n    def __iter__(self):\n        return iter(self._sect)\n\n    def __len__(self):\n        return len(self._sect)\n\n    def __reduce__(self):\n        # TODO: Update\n        return (type(self), (\n            self.toPrimitive(), self._name, self._defs,\n            self._miss\n        ))\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n        new = cls.__new__(cls)\n        memo[id(self)] = new\n        for key, val in self.__dict__.items():\n            self._log(1, '__deepcopy__', f'Deep copying __dict__[{key!r}] = {val!r}')\n            new.__dict__[key] = copy.deepcopy(val, memo)\n        return new\n\n    def __delattr__(self, key):\n        self._log(2, '__delattr__', f'Deleting self._sect[{key!r}]')\n        del self._sect[key]\n\n    def __delitem__(self, key):\n        delattr(self, key)\n\n    def __repr__(self):\n        \"\"\"\n        \"\"\"\n        attrs, sects = [], []\n        for key, value in self.items():\n            self._log(4, '__repr__', f'Checking key [{key!r}] {type(value)} {value!r}')\n            if isinstance(value, Sect):\n                sects.append(key)\n                self._log(4, '__repr__', '\u2514 This key is a Sect')\n            else:\n                attrs.append(key)\n                self._log(4, '__repr__', '\u2514 This key is an Attr')\n\n        # Shorten the length of these strings if there's too many keys\n        if len(attrs) &gt; self._repr:\n            attrs = f'{attrs[:self._repr]}+[{len(attrs)-self._repr} more]'\n        if len(sects) &gt; self._repr:\n            sects = f'{sects[:self._repr]}+[{len(sects)-self._repr} more]'\n\n        # TODO: Expanded formatted repr?\n        return f\"&lt;{type(self).__name__} {self._name or '.'} (Attrs={attrs}, Sects={sects})&gt;\"\n\n    @property\n    def _f(self):\n        \"\"\"\n        A 'flags' function to standardize internal attribute lookups between\n        Sect and Var objects.\n\n        While Vars just use plain words for attributes such as `Var.checks`,\n        Sects use an underscore followed by a standard 4 letters like\n        `Sect._chks`. This property on both classes will access the same desired\n        attribute:\n            Var.checks == Var._f.checks &lt;=&gt; Sect._f.checks == Sect._chks\n\n        Which is useful when iterating over a list that may contain both Var\n        and Sect objects:\n        ```\n        &gt;&gt;&gt; Config({'a': 1, 'b': {}})\n        &gt;&gt;&gt; for key, item in Config.items(var=True):\n        ...     print(key, type(item), item._f.name)\n        a &lt;class 'mlky.configs.var.Var'&gt; .a\n        b &lt;class 'mlky.configs.sect.Sect'&gt; .b\n        ```\n        One caveat: on Var objects this works fine, but on Sect objects this\n        is read-only due to creating a view of internal attributes rather than\n        be the attribute variables themselves\n        \"\"\"\n        return NullDict(\n            name    = self._name,\n            value   = self._sect,\n            dtype   = self._type,\n            defs    = self._defs,\n            checks  = self._chks,\n            debug   = self._debug,\n            parent  = self._prnt,\n            update  = self._update,\n            missing = self._miss,\n        )\n\n    @property\n    def _offset(self):\n        \"\"\"\n        Offset in spaces to denote hierarchical level\n        \"\"\"\n        return '  ' * (len(self._name.split('.')) - 1)\n\n    def _log(self, level, func, msg):\n        \"\"\"\n        Formats debug messages\n        \"\"\"\n        message = f'{self._offset}&lt;{type(self).__name__}&gt;({self._name}).{func}() {msg}'\n        if level == 'e':\n            Logger.error(message)\n        elif level in self._dbug or func in self._dbug:\n            Logger.debug(message)\n\n    def _patch(self, other, inplace=True):\n        \"\"\"\n        Patches this Sect using another Sect or dict\n        \"\"\"\n        if not inplace:\n            self = self.deepCopy()\n            self._log(1, '_patch', 'Patching on deep copy')\n\n        # Auto cast to Sect so merges are easier\n        for key, item in Sect(other).items(var=True):\n            name = self._subkey(key)\n            data = self.get(key, var=True)\n\n            if isinstance(item, Sect):\n                # Patch two Sects together\n                if isinstance(data, Sect):\n                    self._log(1, '_patch', f'Patching sub Sect [{key!r}] = {data} | {item}')\n                    self[key] = data | item\n                # Replace with the other Sect\n                else:\n                    self._log(1, '_patch', f'Adding sub Sect [{key!r}] = {item}')\n                    self[key] = item\n            else:\n                # Log whether this is replacing or adding a Var, or if something borked\n                if isinstance(item, Var):\n                    if isinstance(data, Var):\n                        self._log(1, '_patch', f'Replacing Var [{key!r}] = {item!r}')\n                    else:\n                        self._log(1, '_patch', f'Adding Var [{key!r}] = {item!r}')\n                else:\n                    self._log('e', '_patch', f'A value other than a Sect or Var was found and should not have been: {type(item)} = {item!r}')\n\n                self[key] = item\n\n        # Update the name to reflect potential changes in the hierarchy\n        # self.updateNames()\n\n        return self\n\n    def _subkey(self, key):\n        \"\"\"\n        Formats a key into a subkey name for this Sect\n        \"\"\"\n        if isinstance(key, int):\n            return f'{self._name}[{key}]'\n        return f'{self._name}.{key}'\n\n    def _setdata(self, key, value, defs={}, **kwargs):\n        \"\"\"\n        Sets an item/attribute into the Sect\n\n        Notes\n        -----\n        * Not converting ListTypes (list, tuple) to Sect limits a few capabilities:\n            - These types become Vars, so patching doesn't work. Patching two Sects\n            together will write one Var list over the other\n            - In order for resetVars to work, _opts.VarsReplaceInit will be set to\n            `False` for all child Sects of this list, if _opts.convertItems is `True`\n            This will result in any new Vars created on these Sects will not auto call\n            replace.\n        \"\"\"\n        # Generate the proper name for this key\n        name = self._subkey(key)\n\n        # Retrieve this key from self if it exists\n        self._log(2, '_setdata', f'Retrieving if this key [{key!r}] already exists')\n        data = self._sect[key]\n\n        # Var is the last resort type\n        setVar = False\n\n        # Reduce duplicate code as this is repeated a few times\n        args = dict(\n            name   = name,\n            data   = value,\n            defs   = defs,\n            debug  = self._dbug,\n            parent = self\n        )\n\n        # Already a Var object, typically from unpickling\n        if isinstance(value, Var):\n            self._log(2, '_setdata', f'Input was a Var, setting self[{key!r}] = {value}')\n            self._sect[key] = value\n            value._update(key, self)\n\n        # Already a Sect, typically from patching\n        elif isinstance(value, (type(self), Sect)):\n            self._log(2, '_setdata', f'Input was a Sect, setting self[{key!r}] = {value}')\n            self._sect[key] = value\n            value._update(key, self)\n\n        # These types are Sects, everything else will be Vars\n        elif isinstance(value, dict):\n            self._log(2, '_setdata', f'Setting new Sect [{key!r}] = Sect({value}, defs={defs})')\n            self._sect[key] = Sect(**args, **kwargs)\n\n        # List types may be Sects, depends on options set\n        elif isinstance(value, (list, tuple)):\n            # if convertListTypes then we set a Sect, all other option combinations create a Var\n            setVar = True\n\n            # Default behaviour, cast to a Sect\n            if self._opts.convertListTypes:\n                self._log(2, '_setdata', f'Setting new Sect [{key!r}] = Sect({value}, defs={defs})')\n                self._sect[key] = Sect(**args, **kwargs)\n                setVar = False\n\n            # If not, should the items of the list be converted?\n            elif self._opts.convertItems:\n                self._log(2, '_setdata', f'Setting new List [{key!r}] as Var')\n                opts  = dict(convertListTypes=True, VarsReplaceInit=False)\n                value = Sect(_opts=opts, **args, **kwargs).toPrimitive(deep=False)\n\n        # Key already exists, Var object instantiated\n        elif isinstance(data, Var):\n            # The Var obj will report any issues with setting the value (eg. failed checks)\n            self._log(2, '_setdata', f'Updating existing Var [{key!r}]: {data}.value = {value}')\n            data.value = value\n\n        else:\n            # All other cases will create a new Var\n            setVar = True\n\n        # Create as a Var object\n        if setVar:\n            self._log(2, '_setdata', f'Setting new Var [{key!r}] = Var({value}, kwargs={kwargs}))')\n            self._sect[key] = Var(\n                name    = name,\n                key     = key,\n                value   = value,\n                debug   = self._dbug,\n                parent  = self,\n                replace = self._opts.VarsReplaceInit,\n                **kwargs\n            )\n\n        # Update definitions at the end regardless of input type\n        if defs:\n            self._log(2, '_setdata', f'[{key!r}] Applying defs: {defs}')\n            self._sect[key].applyDefinition(defs)\n\n    def _setdefs(self, key, defs):\n        \"\"\"\n        Sets keys from a definitions dictionary\n        \"\"\"\n        value = Null\n        dtype = defs.get('dtype', 'dict')\n\n        # Children start with '.'\n        if any(key.startswith('.') for key in defs):\n            value = {}\n            if dtype == 'list':\n                value = [{} for _ in range(defs.get('repeat', 1))]\n\n        self._log(1, '_setdefs', f'[{key!r}] = {value!r}, defs={defs}')\n        self._setdata(key, value, defs=defs, missing=True)\n\n    def _update(self, key, parent=Null):\n        \"\"\"\n        Updates parameters of self relative to parent, then updates its children\n\n        Parameters\n        ----------\n        key: str\n            The key the parent is using for this child\n        parent: mlky.Sect, defaults=mlky.Null\n            The parent of this child\n        \"\"\"\n        # Update self\n        internal = self.__dict__\n        internal['_prnt'] = parent\n        internal['_dbug'] = parent._dbug\n\n        # Log important changes\n        old = internal['_name']\n        new = parent._subkey(key)\n        if new is not Null and new != old:\n            self._log(1, '_update', f'Updating name from {old!r} to {new}')\n            internal['_name'] = new\n\n        # Update children\n        self.deepUpdate()\n\n    def applyDefinition(self, defs):\n        \"\"\"\n        Applies a definitions object against this Sect\n        \"\"\"\n        defs = self.loadDict(defs)\n        self.__dict__['_defs'] = defs\n\n        # Apply definitions to child keys, or create the key if missing\n        for key, val in defs.items():\n            if key.startswith('.'):\n                key = key[1:]\n                if key not in self:\n                    self._log(0, 'applyDefinition', f'Adding missing key {key!r}')\n                    self._setdefs(key, val)\n                else:\n                    self._log(0, 'applyDefinition', f'Applying defs to key {key!r}')\n                    self.get(key, var=True).applyDefinition(val)\n\n    def deepUpdate(self):\n        \"\"\"\n        Calls _update() on each Var/Sect in self. This will bring parent/child\n        relationships in line with the current data, such as names and keys\n        \"\"\"\n        for key, item in self.items(var=True):\n            if not isinstance(item, (type(self), Sect, Var)):\n                self._log('e', 'deepUpdate', f'Should never encounter any type other Sect or Var, got: {type(item)} = {item}')\n            item._update(key, self)\n\n    def deepCopy(self, memo=None):\n        \"\"\"\n        Deep copies this Sect\n\n        Parameters\n        ----------\n        memo: dict, defaults=None\n            Deep copy memo to pass. See notes for further detail\n\n        Returns\n        -------\n        type(self)\n            Deep copy of this object\n\n        Notes\n        -----\n        The purpose of the `memo` is to track already once-copied objects in\n        case they are copied again to return faster. Because these are intended\n        to be highly mutable objects, that optimization tends to cause more\n        problems than it's worth. This is disabled by setting `memo` to `None`.\n        However, if you would like to leverage a memo, instantiate a dict\n        variable and pass it as the memo, such as:\n        ```\n        &gt;&gt;&gt; sect = Sect({'a': 1})\n        &gt;&gt;&gt; memo = {}\n        &gt;&gt;&gt; copy = sect.deepCopy(memo)\n        &gt;&gt;&gt; memo\n        {4428805649: &lt;Sect . (Attrs=['a'], Sects=[])&gt;,\n         4432035072: {'a': 1},\n         4433694400: [{'a': 1},\n          {},\n          [],\n          set(),\n          {'a': &lt;Var(a=1)&gt;},\n          &lt;Sect . (Attrs=['a'], Sects=[])&gt;],\n         4429609728: {},\n         4433587008: [],\n         4428133120: set(),\n         4428632752: {'a': &lt;Var(a=1)&gt;},\n         4428805648: &lt;Sect . (Attrs=['a'], Sects=[])&gt;}\n        ```\n        This memo now acts a snapshot of the current state of the object. If you\n        want to recreate this snapshot, call `sect.deepCopy(memo)` again.\n        \"\"\"\n        self._log(0, 'deepCopy', f'Creating deep copy using memo: {memo}')\n        return copy.deepcopy(self, memo)\n\n    def get(self, key, other=None, var=False, default=True):\n        \"\"\"\n        Parameters\n        ----------\n        key: str\n            Item name to look up\n        other: any, defaults=None\n            If\n        var: bool, defaults=False\n            Return the item as a Var\n        default: bool, defaults=True\n            If a default value is available, return that instead of `other`\n        \"\"\"\n        val = self.__getattr__(key, var=var, default=default)\n\n        if val is Null:\n            self._log(3, 'get', f'[{key!r}] Val is Null, returning other: {other!r}')\n            return other\n\n        self._log(3, 'get', f'[{key!r}] Returning value: {val!r}')\n        return val\n\n    def keys(self):\n        return self._sect.keys()\n\n    def values(self, *args, **kwargs):\n        self._log(3, 'values', f'args={args}, kwargs={kwargs}')\n        return [self.__getattr__(key, *args, **kwargs) for key in self]\n\n    def items(self, *args, **kwargs):\n        \"\"\"\n        \"\"\"\n        self._log(3, 'items', f'args={args}, kwargs={kwargs}')\n        return [(key, self.__getattr__(key, *args, **kwargs)) for key in self]\n\n    def hasAttrs(self):\n        \"\"\"\n        Returns whether this Sect has child attributes\n        \"\"\"\n        for key, value in self.items():\n            if isinstance(value, Var):\n                return True\n        return False\n\n    def hasSects(self):\n        \"\"\"\n        Returns whether this Sect has child Sects\n        \"\"\"\n        for key, value in self.items():\n            if isinstance(value, Sect):\n                return True\n        return False\n\n    def toDict(self, deep=True, var=False):\n        \"\"\"\n        Converts the Sect to a dict object\n\n        Parameters\n        ----------\n        deep: bool, defaults=True\n            Will convert child Sects to primitive types as well\n        var: bool, defaults=False\n            Returns the Var object instead of its value\n        \"\"\"\n        data = {}\n        for key, item in self._sect.items():\n            value = self[key]\n            if var:\n                data[key] = item\n            elif deep and isinstance(item, Sect):\n                self._log(0, 'toDict', f'Converting child Sect [{key!r}].toPrimitive()')\n                data[key] = value.toPrimitive(var=var)\n            else:\n                data[key] = value\n\n        return data\n\n    def toList(self, deep=True, var=False):\n        \"\"\"\n        Converts the sect to a list object\n\n        Parameters\n        ----------\n        deep: bool, defaults=True\n            Will convert child Sects to primitive types as well\n        var: bool, defaults=False\n            Returns the Var object instead of its value\n        \"\"\"\n        data = []\n        for key, item in self._sect.items():\n            value = self[key]\n            if var:\n                data.append(item)\n            elif deep and isinstance(item, Sect):\n                self._log(0, 'toList', f'Converting child Sect [{key!r}].toPrimitive()')\n                data.append(value.toPrimitive(var=var))\n            else:\n                data.append(value)\n\n        return data\n\n    def toPrimitive(self, *args, **kwargs):\n        \"\"\"\n        Determines what type of primitive type to convert this Sect to\n\n        Current types:\n            dict\n            list\n        \"\"\"\n        return getattr(self, f'to{self._type}')(*args, **kwargs)\n\n    def resetVars(self):\n        \"\"\"\n        Runs reset on each Var\n        \"\"\"\n        for key, item in self._sect.items():\n            if isinstance(item, Sect):\n                item.resetVars()\n            elif isinstance(item, Var):\n                item.reset()\n            else:\n                self._log('e', 'resetVars', f'Internal _sect has a value other than a Var or Sect: {key!r} = {item!r}')\n\n    def dumpYaml(self, string=True):\n        \"\"\"\n        Dumps this object as a YAML string.\n\n        Leverages the yaml.dump function to ensure 'key: value' are yaml\n        compatible\n\n        Parameters\n        ----------\n        string: bool, default=True\n            Converts the dump to a compatible YAML string. If false, returns\n            the dump list which is a list of tuples where each tuple defines the\n            column values for a given row\n\n        Notes\n        -----\n        `string=False` will return the `dump` list. The `dump` list is a list\n        of tuples, ie.\n        ```\n        dump = [\n            (string, flag, dtype, sdesc), # Line 1\n            (string, flag, dtype, sdesc), # Line 2\n            ...\n        ]\n        ```\n        This list is in order. If the order changes, it risks becoming an\n        invalid YAML. This list is formatted as such so that it can be easily\n        passed to `mlky.utils.printTable()`. See `Sect.generateTemplate()` for\n        more information about this.\n        \"\"\"\n        def rowFromSect(string, sect):\n            \"\"\"\n            Reads a Sect and prepares a tuple that represents the row as the\n            following columns:\n                (string, flag, dtype, sdesc)\n            \"\"\"\n            defs = sect._defs\n\n            sdesc = defs.get('sdesc', '')\n            dtype = defs.get('dtype', self._type.lower())\n\n            # ! = required, ? = optional under a required sect, ' ' = optional\n            flag = ' '\n            if defs.get('required'):\n                flag = '!'\n            else:\n                parent = sect._prnt\n                while parent is not Null:\n                    if parent._defs.get('required'):\n                        flag = '?'\n                        break\n                    parent = parent._prnt\n\n            return (string, flag, dtype, sdesc)\n\n\n        def rowFromVar(var):\n            \"\"\"\n            Reads a Var and prepares a tuple that represents the row as the\n            following columns:\n                (string, flag, dtype, sdesc)\n            where:\n                `string` is the \"key: value\" for this line\n                `flag` is one of:\n                    ` ` - Completely optional key\n                    `!` - Manually set value required\n                    `?` - Optional child key of some required parent section\n                `dtype` is the set data type for this key\n                `sdesc` is the short description\n\n            This list of tuples is then processed by utils.printTable() to the\n            columns in alignment as a valid yaml\n            \"\"\"\n            # Set value if set, otherwise use default, replace Null with `\\`\n            value  = '\\\\'\n            if var.value is not Null:\n                value = var.value\n            elif var.default is not Null:\n                value = var.default\n\n            flag = ' '\n            if var.required:\n                flag = '!'\n            else:\n                parent = var.parent\n                while parent is not Null:\n                    if parent._defs.get('required'):\n                        flag = '?'\n                        break\n                    parent = parent._prnt\n\n            # Use yaml to dump this correctly\n            if self._type == 'List':\n                strings = ['- ' + yaml.dump(value)[:-5]]\n            else:\n                strings = yaml.dump({key: value}).split('\\n')[:-1]\n\n            # If this is a list value, there will be multiple lines\n            others = []\n            if len(strings) &gt; 1:\n                offset = var._offset + '  '\n                others = [\n                    (offset+string, )\n                    for string in strings[1:]\n                ]\n\n            # The main key line\n            string = var._offset + strings[0]\n\n            return [(string, flag, var.dtype or '', var.sdesc)] + others\n\n\n        dump = [('generated:', 'K', 'dtype', 'Short description')]\n        for key, item in self._sect.items():\n            if isinstance(item, Sect):\n                # `key` is not in the item, create the \"key: value\" string for the row tuple\n                dump.append(rowFromSect(f'{item._offset}{key}:', item))\n                dump += item.dumpYaml(string=False)[1:]\n            elif isinstance(item, Var):\n                dump += rowFromVar(item)\n            else:\n                self._log('e', 'dumpYaml', f'Internal _sect has a value other than a Var or Sect: {key!r} = {item!r}')\n\n        if string:\n            return '\\n'.join(\n                printTable(dump, columns = {\n                        0: {'delimiter': '#'},\n                        1: {'delimiter': '|'},\n                    }, print=None\n                )\n            )\n        return dump\n\n    def generateTemplate(self, file=None):\n        \"\"\"\n        Generates a YAML template file\n        \"\"\"\n        dump = yamlHeader + self.dumpYaml(string=True)\n\n        if file:\n            with open(file, 'w') as f:\n                f.write(dump)\n\n    def loadDict(self, data):\n        \"\"\"\n        Loads a dict from various options:\n            - Files:\n                - .json\n                - .yaml, .yml\n            - Strings:\n                - yaml formatted\n                - pathlib.Path\n            - Returns these types as-is:\n                - type(self)\n                - Sect\n                - dict\n                - list\n                - tuple\n\n        Parameters\n        ----------\n        data: varies\n            One of the various supported types in the function description\n\n        Returns\n        -------\n        \"\"\"\n        # Dicts and Sects return as-is\n        dtypes = [type(self), Sect, dict, list, tuple]\n        if isinstance(data, tuple(dtypes)):\n            return data\n\n        dtypes += ['yaml', 'json', 'pathlib.Path']\n        if isinstance(data, (str, Path)):\n            # File case\n            if os.path.isfile(data):\n                _, ext = os.path.splitext(data)\n\n                if ext in ['.yml', '.yaml']:\n                    with open(data, 'r') as file:\n                        data = yaml.load(file, Loader=yaml.FullLoader)\n                elif ext in ['.json']:\n                    return json.loads(data)\n\n            else:\n                try:\n                    # Raw yaml strings supported only\n                    data = yaml.load(data, Loader=yaml.FullLoader)\n                except:\n                    raise TypeError('Data input is a string but is not a file nor a yaml string')\n\n            return data\n\n        else:\n            raise TypeError(f'Data input is not a supported type, got {type(data)!r} expected one of: {dtypes}')\n</code></pre>"},{"location":"api/sect/#mlky.Sect.__call__","title":"<code>__call__(other, inplace=True)</code>","text":"<p>Enables patching via call, Sect(other)</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def __call__(self, other, inplace=True):\n    \"\"\"\n    Enables patching via call, Sect(other)\n    \"\"\"\n    if isinstance(other, (type(self), dict)):\n        return self._patch(other, inplace=inplace)\n    raise TypeError(f'mlky.Sect can only be patched using other dicts or Sects')\n</code></pre>"},{"location":"api/sect/#mlky.Sect.__getattr__","title":"<code>__getattr__(key, var=False, default=True)</code>","text":"<p>Interfaces with _sect to retrieve the Var and Sect child objects _sect should always be a NullDict</p> <p>Parameters are accessible via the .get() method</p>"},{"location":"api/sect/#mlky.Sect.__getattr__--parameters","title":"Parameters","text":"<p>key: str     Attribute name to look up var: bool, defaults=False     Return the item as a Var default: bool, defaults=True     Return a Var's default value if available</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def __getattr__(self, key, var=False, default=True):\n    \"\"\"\n    Interfaces with _sect to retrieve the Var and Sect child objects\n    _sect should always be a NullDict\n\n    Parameters are accessible via the .get() method\n\n    Parameters\n    ----------\n    key: str\n        Attribute name to look up\n    var: bool, defaults=False\n        Return the item as a Var\n    default: bool, defaults=True\n        Return a Var's default value if available\n    \"\"\"\n    val = self._sect[key]\n\n    if isinstance(val, Var):\n        if var:\n            self._log(3, '__getattr__', f'[{key!r}] Returning as Var: {val}')\n            return val\n\n        if default and val.value is Null:\n            self._log(3, '__getattr__', f'[{key!r}] Returning {val}.default')\n            return val.default\n\n        self._log(3, '__getattr__', f'[{key!r}] Returning {val}.value')\n        return val.value\n\n    if not isinstance(val, (Sect, NullType)):\n        self._log('e', '__getattr__', f'Item of _sect is not a Var, Sect, or Null type: [{key!r}] = {type(val)} {val}')\n\n    self._log(3, '__getattr__', f'[{key!r}] Returning value: {val!r}')\n    return val\n</code></pre>"},{"location":"api/sect/#mlky.Sect.__init__","title":"<code>__init__(data={}, name='', defs={}, missing=False, debug=-1, parent=Null, _opts={}, **kwargs)</code>","text":""},{"location":"api/sect/#mlky.Sect.__init__--parameters","title":"Parameters","text":"<p>debug: int or list, defaults=-1     Controls the verbosity of the class. Higher values is increased     verbosity. Current levels:         -1: Default, disables debug messages          0: Non-private functions (non-underscore named functions)          1: Private functions (single underscores)          2: _setdata()          3: getattr, get(), items()          4: Repr, very spammy     If passed as a list of ints, will only enable those levels.     If the list is comprised of strings, any function names in this list     will be enabled _opts: dict, defaults={}     Override options for this Sect and its children only. This will also detach     this Sect from the global options, so those changes will not propogate</p>"},{"location":"api/sect/#mlky.Sect.__init__--notes","title":"Notes","text":"<p>Initialization support: - From Sect     = Sect(Sect({...})) - From dict     = Sect({'a': 1, 'b': 2}) - From list     = Sect(['a', 'b']) - From tuple    = Sect(('a', 'b')) - As a function = Sect(a=1, b=2)</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def __init__(self,\n    data    = {},\n    name    = \"\",\n    defs    = {},\n    missing = False,\n    debug   = -1,\n    parent  = Null,\n    _opts   = {},\n    **kwargs\n):\n    \"\"\"\n    Parameters\n    ----------\n    debug: int or list, defaults=-1\n        Controls the verbosity of the class. Higher values is increased\n        verbosity. Current levels:\n            -1: Default, disables debug messages\n             0: Non-private functions (non-underscore named functions)\n             1: Private functions (single underscores)\n             2: _setdata()\n             3: getattr, get(), items()\n             4: Repr, very spammy\n        If passed as a list of ints, will only enable those levels.\n        If the list is comprised of strings, any function names in this list\n        will be enabled\n    _opts: dict, defaults={}\n        Override options for this Sect and its children only. This will also detach\n        this Sect from the global options, so those changes will not propogate\n\n    Notes\n    -----\n    Initialization support:\n    - From Sect     = Sect(Sect({...}))\n    - From dict     = Sect({'a': 1, 'b': 2})\n    - From list     = Sect(['a', 'b'])\n    - From tuple    = Sect(('a', 'b'))\n    - As a function = Sect(a=1, b=2)\n    \"\"\"\n    if isinstance(debug, int):\n        debug = range(0, debug+1)\n\n    # Override the options for this Sect if given\n    if _opts:\n        self.__dict__['_opts'] = NullDict(self._opts | _opts)\n\n    # Parse the input data from a supported type\n    data = self.loadDict(data)\n\n    self.__dict__['_name'] = name\n    self.__dict__['_data'] = data\n    self.__dict__['_miss'] = missing\n    self.__dict__['_dbug'] = set(debug)\n    self.__dict__['_prnt'] = parent\n    self.__dict__['_chks'] = []\n    self.__dict__['_sect'] = NullDict()\n\n    if isinstance(data, dict):\n        # if the input data is a dict, combine with kwargs to allow mix inputs eg. Sect({'a': 1}, b=2)\n        for key, value in (kwargs | data).items():\n            self._setdata(key, value,\n                defs = defs.get(f'.{key}', {})\n            )\n\n    elif isinstance(data, (list, tuple)):\n        # Flag that this is a list-type Sect to change some downstream behaviours\n        self.__dict__['_type'] = 'List'\n        for i, value in enumerate(data):\n            self._setdata(i, value, defs=defs)\n\n    elif isinstance(data, Sect):\n        super().__setattr__('__dict__', data.deepCopy().__dict__)\n\n    if defs:\n        self.applyDefinition(defs)\n</code></pre>"},{"location":"api/sect/#mlky.Sect.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Enables patching using the &lt; operator</p>"},{"location":"api/sect/#mlky.Sect.__lt__--notes","title":"Notes","text":"<p>To enable subclass patching behaviour with both itself and this class, check if isinstance of itself and Sect</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def __lt__(self, other):\n    \"\"\"\n    Enables patching using the &lt; operator\n\n    Notes\n    -----\n    To enable subclass patching behaviour with both itself and this class,\n    check if isinstance of itself and Sect\n    \"\"\"\n    if isinstance(other, (type(self), Sect, dict)):\n        return self._patch(other, inplace=False)\n    raise TypeError(f'mlky.Sect can only use operator &lt; (lt) with other dicts or Sects')\n</code></pre>"},{"location":"api/sect/#mlky.Sect.__or__","title":"<code>__or__(other)</code>","text":"<p>Enables patching using the | operator</p>"},{"location":"api/sect/#mlky.Sect.__or__--notes","title":"Notes","text":"<p>To enable subclass patching behaviour with both itself and this class, check if isinstance of itself and Sect</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def __or__(self, other):\n    \"\"\"\n    Enables patching using the | operator\n\n    Notes\n    -----\n    To enable subclass patching behaviour with both itself and this class,\n    check if isinstance of itself and Sect\n    \"\"\"\n    if isinstance(other, (type(self), Sect, dict)):\n        return self._patch(other, inplace=False)\n    raise TypeError(f'mlky.Sect can only use operator | (or) with other dicts or Sects')\n</code></pre>"},{"location":"api/sect/#mlky.Sect.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>mlky/configs/sect.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    \"\"\"\n    attrs, sects = [], []\n    for key, value in self.items():\n        self._log(4, '__repr__', f'Checking key [{key!r}] {type(value)} {value!r}')\n        if isinstance(value, Sect):\n            sects.append(key)\n            self._log(4, '__repr__', '\u2514 This key is a Sect')\n        else:\n            attrs.append(key)\n            self._log(4, '__repr__', '\u2514 This key is an Attr')\n\n    # Shorten the length of these strings if there's too many keys\n    if len(attrs) &gt; self._repr:\n        attrs = f'{attrs[:self._repr]}+[{len(attrs)-self._repr} more]'\n    if len(sects) &gt; self._repr:\n        sects = f'{sects[:self._repr]}+[{len(sects)-self._repr} more]'\n\n    # TODO: Expanded formatted repr?\n    return f\"&lt;{type(self).__name__} {self._name or '.'} (Attrs={attrs}, Sects={sects})&gt;\"\n</code></pre>"},{"location":"api/sect/#mlky.Sect.applyDefinition","title":"<code>applyDefinition(defs)</code>","text":"<p>Applies a definitions object against this Sect</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def applyDefinition(self, defs):\n    \"\"\"\n    Applies a definitions object against this Sect\n    \"\"\"\n    defs = self.loadDict(defs)\n    self.__dict__['_defs'] = defs\n\n    # Apply definitions to child keys, or create the key if missing\n    for key, val in defs.items():\n        if key.startswith('.'):\n            key = key[1:]\n            if key not in self:\n                self._log(0, 'applyDefinition', f'Adding missing key {key!r}')\n                self._setdefs(key, val)\n            else:\n                self._log(0, 'applyDefinition', f'Applying defs to key {key!r}')\n                self.get(key, var=True).applyDefinition(val)\n</code></pre>"},{"location":"api/sect/#mlky.Sect.deepCopy","title":"<code>deepCopy(memo=None)</code>","text":"<p>Deep copies this Sect</p>"},{"location":"api/sect/#mlky.Sect.deepCopy--parameters","title":"Parameters","text":"<p>memo: dict, defaults=None     Deep copy memo to pass. See notes for further detail</p>"},{"location":"api/sect/#mlky.Sect.deepCopy--returns","title":"Returns","text":"<p>type(self)     Deep copy of this object</p>"},{"location":"api/sect/#mlky.Sect.deepCopy--notes","title":"Notes","text":"<p>The purpose of the <code>memo</code> is to track already once-copied objects in case they are copied again to return faster. Because these are intended to be highly mutable objects, that optimization tends to cause more problems than it's worth. This is disabled by setting <code>memo</code> to <code>None</code>. However, if you would like to leverage a memo, instantiate a dict variable and pass it as the memo, such as:</p> <pre><code>&gt;&gt;&gt; sect = Sect({'a': 1})\n&gt;&gt;&gt; memo = {}\n&gt;&gt;&gt; copy = sect.deepCopy(memo)\n&gt;&gt;&gt; memo\n{4428805649: &lt;Sect . (Attrs=['a'], Sects=[])&gt;,\n 4432035072: {'a': 1},\n 4433694400: [{'a': 1},\n  {},\n  [],\n  set(),\n  {'a': &lt;Var(a=1)&gt;},\n  &lt;Sect . (Attrs=['a'], Sects=[])&gt;],\n 4429609728: {},\n 4433587008: [],\n 4428133120: set(),\n 4428632752: {'a': &lt;Var(a=1)&gt;},\n 4428805648: &lt;Sect . (Attrs=['a'], Sects=[])&gt;}\n</code></pre> <p>This memo now acts a snapshot of the current state of the object. If you want to recreate this snapshot, call <code>sect.deepCopy(memo)</code> again.</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def deepCopy(self, memo=None):\n    \"\"\"\n    Deep copies this Sect\n\n    Parameters\n    ----------\n    memo: dict, defaults=None\n        Deep copy memo to pass. See notes for further detail\n\n    Returns\n    -------\n    type(self)\n        Deep copy of this object\n\n    Notes\n    -----\n    The purpose of the `memo` is to track already once-copied objects in\n    case they are copied again to return faster. Because these are intended\n    to be highly mutable objects, that optimization tends to cause more\n    problems than it's worth. This is disabled by setting `memo` to `None`.\n    However, if you would like to leverage a memo, instantiate a dict\n    variable and pass it as the memo, such as:\n    ```\n    &gt;&gt;&gt; sect = Sect({'a': 1})\n    &gt;&gt;&gt; memo = {}\n    &gt;&gt;&gt; copy = sect.deepCopy(memo)\n    &gt;&gt;&gt; memo\n    {4428805649: &lt;Sect . (Attrs=['a'], Sects=[])&gt;,\n     4432035072: {'a': 1},\n     4433694400: [{'a': 1},\n      {},\n      [],\n      set(),\n      {'a': &lt;Var(a=1)&gt;},\n      &lt;Sect . (Attrs=['a'], Sects=[])&gt;],\n     4429609728: {},\n     4433587008: [],\n     4428133120: set(),\n     4428632752: {'a': &lt;Var(a=1)&gt;},\n     4428805648: &lt;Sect . (Attrs=['a'], Sects=[])&gt;}\n    ```\n    This memo now acts a snapshot of the current state of the object. If you\n    want to recreate this snapshot, call `sect.deepCopy(memo)` again.\n    \"\"\"\n    self._log(0, 'deepCopy', f'Creating deep copy using memo: {memo}')\n    return copy.deepcopy(self, memo)\n</code></pre>"},{"location":"api/sect/#mlky.Sect.deepUpdate","title":"<code>deepUpdate()</code>","text":"<p>Calls _update() on each Var/Sect in self. This will bring parent/child relationships in line with the current data, such as names and keys</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def deepUpdate(self):\n    \"\"\"\n    Calls _update() on each Var/Sect in self. This will bring parent/child\n    relationships in line with the current data, such as names and keys\n    \"\"\"\n    for key, item in self.items(var=True):\n        if not isinstance(item, (type(self), Sect, Var)):\n            self._log('e', 'deepUpdate', f'Should never encounter any type other Sect or Var, got: {type(item)} = {item}')\n        item._update(key, self)\n</code></pre>"},{"location":"api/sect/#mlky.Sect.dumpYaml","title":"<code>dumpYaml(string=True)</code>","text":"<p>Dumps this object as a YAML string.</p> <p>Leverages the yaml.dump function to ensure 'key: value' are yaml compatible</p>"},{"location":"api/sect/#mlky.Sect.dumpYaml--parameters","title":"Parameters","text":"<p>string: bool, default=True     Converts the dump to a compatible YAML string. If false, returns     the dump list which is a list of tuples where each tuple defines the     column values for a given row</p>"},{"location":"api/sect/#mlky.Sect.dumpYaml--notes","title":"Notes","text":"<p><code>string=False</code> will return the <code>dump</code> list. The <code>dump</code> list is a list of tuples, ie.</p> <pre><code>dump = [\n    (string, flag, dtype, sdesc), # Line 1\n    (string, flag, dtype, sdesc), # Line 2\n    ...\n]\n</code></pre> <p>This list is in order. If the order changes, it risks becoming an invalid YAML. This list is formatted as such so that it can be easily passed to <code>mlky.utils.printTable()</code>. See <code>Sect.generateTemplate()</code> for more information about this.</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def dumpYaml(self, string=True):\n    \"\"\"\n    Dumps this object as a YAML string.\n\n    Leverages the yaml.dump function to ensure 'key: value' are yaml\n    compatible\n\n    Parameters\n    ----------\n    string: bool, default=True\n        Converts the dump to a compatible YAML string. If false, returns\n        the dump list which is a list of tuples where each tuple defines the\n        column values for a given row\n\n    Notes\n    -----\n    `string=False` will return the `dump` list. The `dump` list is a list\n    of tuples, ie.\n    ```\n    dump = [\n        (string, flag, dtype, sdesc), # Line 1\n        (string, flag, dtype, sdesc), # Line 2\n        ...\n    ]\n    ```\n    This list is in order. If the order changes, it risks becoming an\n    invalid YAML. This list is formatted as such so that it can be easily\n    passed to `mlky.utils.printTable()`. See `Sect.generateTemplate()` for\n    more information about this.\n    \"\"\"\n    def rowFromSect(string, sect):\n        \"\"\"\n        Reads a Sect and prepares a tuple that represents the row as the\n        following columns:\n            (string, flag, dtype, sdesc)\n        \"\"\"\n        defs = sect._defs\n\n        sdesc = defs.get('sdesc', '')\n        dtype = defs.get('dtype', self._type.lower())\n\n        # ! = required, ? = optional under a required sect, ' ' = optional\n        flag = ' '\n        if defs.get('required'):\n            flag = '!'\n        else:\n            parent = sect._prnt\n            while parent is not Null:\n                if parent._defs.get('required'):\n                    flag = '?'\n                    break\n                parent = parent._prnt\n\n        return (string, flag, dtype, sdesc)\n\n\n    def rowFromVar(var):\n        \"\"\"\n        Reads a Var and prepares a tuple that represents the row as the\n        following columns:\n            (string, flag, dtype, sdesc)\n        where:\n            `string` is the \"key: value\" for this line\n            `flag` is one of:\n                ` ` - Completely optional key\n                `!` - Manually set value required\n                `?` - Optional child key of some required parent section\n            `dtype` is the set data type for this key\n            `sdesc` is the short description\n\n        This list of tuples is then processed by utils.printTable() to the\n        columns in alignment as a valid yaml\n        \"\"\"\n        # Set value if set, otherwise use default, replace Null with `\\`\n        value  = '\\\\'\n        if var.value is not Null:\n            value = var.value\n        elif var.default is not Null:\n            value = var.default\n\n        flag = ' '\n        if var.required:\n            flag = '!'\n        else:\n            parent = var.parent\n            while parent is not Null:\n                if parent._defs.get('required'):\n                    flag = '?'\n                    break\n                parent = parent._prnt\n\n        # Use yaml to dump this correctly\n        if self._type == 'List':\n            strings = ['- ' + yaml.dump(value)[:-5]]\n        else:\n            strings = yaml.dump({key: value}).split('\\n')[:-1]\n\n        # If this is a list value, there will be multiple lines\n        others = []\n        if len(strings) &gt; 1:\n            offset = var._offset + '  '\n            others = [\n                (offset+string, )\n                for string in strings[1:]\n            ]\n\n        # The main key line\n        string = var._offset + strings[0]\n\n        return [(string, flag, var.dtype or '', var.sdesc)] + others\n\n\n    dump = [('generated:', 'K', 'dtype', 'Short description')]\n    for key, item in self._sect.items():\n        if isinstance(item, Sect):\n            # `key` is not in the item, create the \"key: value\" string for the row tuple\n            dump.append(rowFromSect(f'{item._offset}{key}:', item))\n            dump += item.dumpYaml(string=False)[1:]\n        elif isinstance(item, Var):\n            dump += rowFromVar(item)\n        else:\n            self._log('e', 'dumpYaml', f'Internal _sect has a value other than a Var or Sect: {key!r} = {item!r}')\n\n    if string:\n        return '\\n'.join(\n            printTable(dump, columns = {\n                    0: {'delimiter': '#'},\n                    1: {'delimiter': '|'},\n                }, print=None\n            )\n        )\n    return dump\n</code></pre>"},{"location":"api/sect/#mlky.Sect.generateTemplate","title":"<code>generateTemplate(file=None)</code>","text":"<p>Generates a YAML template file</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def generateTemplate(self, file=None):\n    \"\"\"\n    Generates a YAML template file\n    \"\"\"\n    dump = yamlHeader + self.dumpYaml(string=True)\n\n    if file:\n        with open(file, 'w') as f:\n            f.write(dump)\n</code></pre>"},{"location":"api/sect/#mlky.Sect.get","title":"<code>get(key, other=None, var=False, default=True)</code>","text":""},{"location":"api/sect/#mlky.Sect.get--parameters","title":"Parameters","text":"<p>key: str     Item name to look up other: any, defaults=None     If var: bool, defaults=False     Return the item as a Var default: bool, defaults=True     If a default value is available, return that instead of <code>other</code></p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def get(self, key, other=None, var=False, default=True):\n    \"\"\"\n    Parameters\n    ----------\n    key: str\n        Item name to look up\n    other: any, defaults=None\n        If\n    var: bool, defaults=False\n        Return the item as a Var\n    default: bool, defaults=True\n        If a default value is available, return that instead of `other`\n    \"\"\"\n    val = self.__getattr__(key, var=var, default=default)\n\n    if val is Null:\n        self._log(3, 'get', f'[{key!r}] Val is Null, returning other: {other!r}')\n        return other\n\n    self._log(3, 'get', f'[{key!r}] Returning value: {val!r}')\n    return val\n</code></pre>"},{"location":"api/sect/#mlky.Sect.hasAttrs","title":"<code>hasAttrs()</code>","text":"<p>Returns whether this Sect has child attributes</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def hasAttrs(self):\n    \"\"\"\n    Returns whether this Sect has child attributes\n    \"\"\"\n    for key, value in self.items():\n        if isinstance(value, Var):\n            return True\n    return False\n</code></pre>"},{"location":"api/sect/#mlky.Sect.hasSects","title":"<code>hasSects()</code>","text":"<p>Returns whether this Sect has child Sects</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def hasSects(self):\n    \"\"\"\n    Returns whether this Sect has child Sects\n    \"\"\"\n    for key, value in self.items():\n        if isinstance(value, Sect):\n            return True\n    return False\n</code></pre>"},{"location":"api/sect/#mlky.Sect.items","title":"<code>items(*args, **kwargs)</code>","text":"Source code in <code>mlky/configs/sect.py</code> <pre><code>def items(self, *args, **kwargs):\n    \"\"\"\n    \"\"\"\n    self._log(3, 'items', f'args={args}, kwargs={kwargs}')\n    return [(key, self.__getattr__(key, *args, **kwargs)) for key in self]\n</code></pre>"},{"location":"api/sect/#mlky.Sect.loadDict","title":"<code>loadDict(data)</code>","text":"Loads a dict from various options <ul> <li>Files:<ul> <li>.json</li> <li>.yaml, .yml</li> </ul> </li> <li>Strings:<ul> <li>yaml formatted</li> <li>pathlib.Path</li> </ul> </li> <li>Returns these types as-is:<ul> <li>type(self)</li> <li>Sect</li> <li>dict</li> <li>list</li> <li>tuple</li> </ul> </li> </ul>"},{"location":"api/sect/#mlky.Sect.loadDict--parameters","title":"Parameters","text":"<p>data: varies     One of the various supported types in the function description</p>"},{"location":"api/sect/#mlky.Sect.loadDict--returns","title":"Returns","text":"Source code in <code>mlky/configs/sect.py</code> <pre><code>def loadDict(self, data):\n    \"\"\"\n    Loads a dict from various options:\n        - Files:\n            - .json\n            - .yaml, .yml\n        - Strings:\n            - yaml formatted\n            - pathlib.Path\n        - Returns these types as-is:\n            - type(self)\n            - Sect\n            - dict\n            - list\n            - tuple\n\n    Parameters\n    ----------\n    data: varies\n        One of the various supported types in the function description\n\n    Returns\n    -------\n    \"\"\"\n    # Dicts and Sects return as-is\n    dtypes = [type(self), Sect, dict, list, tuple]\n    if isinstance(data, tuple(dtypes)):\n        return data\n\n    dtypes += ['yaml', 'json', 'pathlib.Path']\n    if isinstance(data, (str, Path)):\n        # File case\n        if os.path.isfile(data):\n            _, ext = os.path.splitext(data)\n\n            if ext in ['.yml', '.yaml']:\n                with open(data, 'r') as file:\n                    data = yaml.load(file, Loader=yaml.FullLoader)\n            elif ext in ['.json']:\n                return json.loads(data)\n\n        else:\n            try:\n                # Raw yaml strings supported only\n                data = yaml.load(data, Loader=yaml.FullLoader)\n            except:\n                raise TypeError('Data input is a string but is not a file nor a yaml string')\n\n        return data\n\n    else:\n        raise TypeError(f'Data input is not a supported type, got {type(data)!r} expected one of: {dtypes}')\n</code></pre>"},{"location":"api/sect/#mlky.Sect.resetVars","title":"<code>resetVars()</code>","text":"<p>Runs reset on each Var</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def resetVars(self):\n    \"\"\"\n    Runs reset on each Var\n    \"\"\"\n    for key, item in self._sect.items():\n        if isinstance(item, Sect):\n            item.resetVars()\n        elif isinstance(item, Var):\n            item.reset()\n        else:\n            self._log('e', 'resetVars', f'Internal _sect has a value other than a Var or Sect: {key!r} = {item!r}')\n</code></pre>"},{"location":"api/sect/#mlky.Sect.toDict","title":"<code>toDict(deep=True, var=False)</code>","text":"<p>Converts the Sect to a dict object</p>"},{"location":"api/sect/#mlky.Sect.toDict--parameters","title":"Parameters","text":"<p>deep: bool, defaults=True     Will convert child Sects to primitive types as well var: bool, defaults=False     Returns the Var object instead of its value</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def toDict(self, deep=True, var=False):\n    \"\"\"\n    Converts the Sect to a dict object\n\n    Parameters\n    ----------\n    deep: bool, defaults=True\n        Will convert child Sects to primitive types as well\n    var: bool, defaults=False\n        Returns the Var object instead of its value\n    \"\"\"\n    data = {}\n    for key, item in self._sect.items():\n        value = self[key]\n        if var:\n            data[key] = item\n        elif deep and isinstance(item, Sect):\n            self._log(0, 'toDict', f'Converting child Sect [{key!r}].toPrimitive()')\n            data[key] = value.toPrimitive(var=var)\n        else:\n            data[key] = value\n\n    return data\n</code></pre>"},{"location":"api/sect/#mlky.Sect.toList","title":"<code>toList(deep=True, var=False)</code>","text":"<p>Converts the sect to a list object</p>"},{"location":"api/sect/#mlky.Sect.toList--parameters","title":"Parameters","text":"<p>deep: bool, defaults=True     Will convert child Sects to primitive types as well var: bool, defaults=False     Returns the Var object instead of its value</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def toList(self, deep=True, var=False):\n    \"\"\"\n    Converts the sect to a list object\n\n    Parameters\n    ----------\n    deep: bool, defaults=True\n        Will convert child Sects to primitive types as well\n    var: bool, defaults=False\n        Returns the Var object instead of its value\n    \"\"\"\n    data = []\n    for key, item in self._sect.items():\n        value = self[key]\n        if var:\n            data.append(item)\n        elif deep and isinstance(item, Sect):\n            self._log(0, 'toList', f'Converting child Sect [{key!r}].toPrimitive()')\n            data.append(value.toPrimitive(var=var))\n        else:\n            data.append(value)\n\n    return data\n</code></pre>"},{"location":"api/sect/#mlky.Sect.toPrimitive","title":"<code>toPrimitive(*args, **kwargs)</code>","text":"<p>Determines what type of primitive type to convert this Sect to</p> Current types <p>dict list</p> Source code in <code>mlky/configs/sect.py</code> <pre><code>def toPrimitive(self, *args, **kwargs):\n    \"\"\"\n    Determines what type of primitive type to convert this Sect to\n\n    Current types:\n        dict\n        list\n    \"\"\"\n    return getattr(self, f'to{self._type}')(*args, **kwargs)\n</code></pre>"},{"location":"api/templates/","title":"api/utils/templates","text":"<p>Stores useful templates</p>"},{"location":"api/var/","title":"api/configs/Var","text":"Source code in <code>mlky/configs/var.py</code> <pre><code>class Var:\n    value    = Null\n    debug    = set()\n    missing  = True\n    required = False\n\n    def __init__(self, name, key,\n        value    = Null,\n        default  = Null,\n        dtype    = Null,\n        required = False,\n        missing  = False,\n        checks   = [],\n        debug    = -1,\n        sdesc    = '',\n        ldesc    = '',\n        parent   = Null,\n        replace  = True\n    ):\n        \"\"\"\n        Variable container object\n\n        Parameters\n        ----------\n        replace: bool, defaults=True\n            Use the default Var.__setattr__ which will call replace() on `value`\n            If `False`, circumvents Var.__setattr__ by using super().__setattr__\n        \"\"\"\n        if isinstance(debug, int):\n            debug = range(0, debug+1)\n\n        self.name     = name\n        self.key      = key\n        self.default  = default\n        self.dtype    = dtype\n        self.required = required\n        self.missing  = missing\n        self.checks   = checks\n        self.debug    = set(debug)\n        self.sdesc    = sdesc\n        self.ldesc    = ldesc\n        self.parent   = parent\n        self.original = value\n\n        if replace:\n            # This will call replace() then validate()\n            self.value = value\n        else:\n            # No replace(), takes as-is\n            super().__setattr__('value', value)\n\n    def __eq__(self, other):\n        data = self.toDict()\n        if isinstance(other, dict):\n            return data == other\n        elif isinstance(other, self.__class__):\n            return data == other.toDict()\n        return False\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n        new = cls.__new__(cls)\n        memo[id(self)] = new\n        for key, val in self.__dict__.items():\n            self._debug(1, '__deepcopy__', f'Deep copying __dict__[{key!r}] = {val!r}')\n            new.__dict__[key] = copy.deepcopy(val, memo)\n        return new\n\n    def __reduce__(self):\n        return (type(self), (\n            self.name, self.key, self.value,\n            self.default, self.dtype, self.required,\n            self.missing, self.checks\n        ))\n\n    def deepReplace(self, value):\n        \"\"\"\n        Calls reset on the children of this Var's value if it is a list type\n        \"\"\"\n        for i, item in enumerate(value):\n            if 'Sect' in str(type(item)):\n                self._debug(2, 'deepReplace', f'Resetting {item}')\n                item.resetVars()\n\n            elif isinstance(item, str):\n                new = self.replace(item)\n                if new is not None:\n                    self._debug(2, 'deepReplace', f'Replacing index [{i}] {item!r} with {new!r}')\n                    value[i] = new\n\n            elif isinstance(item, (list, tuple)):\n                self._debug(2, 'deepReplace', f'Calling deepReplace on child list {item}')\n                self.deepReplace(item)\n\n    def __setattr__(self, key, value):\n        \"\"\"\n        \"\"\"\n        if key == 'value':\n            # Lists to Sects disabled, perform a deep replacement\n            if isinstance(value, (list, tuple)):\n                self.original = copy.deepcopy(value)\n                self.deepReplace(value)\n            else:\n                # Always call to see if this value should be replaced\n                new = self.replace(value)\n                if new is not None:\n                    self.original = value\n                    value = new\n\n            # No longer missing if it's set\n            self.missing = False\n\n            # Non-empty dict means errors found\n            if self.validate(value).reduce():\n                Logger.error(f'Changing the value of this Var({self.name}) will cause validation to fail. See var.validate() for errors.')\n\n        super().__setattr__(key, value)\n\n    def __repr__(self):\n        return f'&lt;Var({self.key}={self.value!r})&gt;'\n\n    @property\n    def _f(self):\n        \"\"\"\n        A 'flags' function to standardize internal attribute lookups between\n        Sect and Var objects.\n\n        While Vars just use plain words for attributes such as `Var.checks`,\n        Sects use an underscore followed by a standard 4 letters like\n        `Sect._chks`. This property on both classes will access the same desired\n        attribute:\n            Var.checks == Var._f.checks &lt;=&gt; Sect._f.checks == Sect._chks\n\n        Which is useful when iterating over a list that may contain both Var\n        and Sect objects:\n        ```\n        &gt;&gt;&gt; Config({'a': 1, 'b': {}})\n        &gt;&gt;&gt; for key, item in Config.items(var=True):\n        ...     print(key, type(item), item._f.name)\n        a &lt;class 'mlky.configs.var.Var'&gt; .a\n        b &lt;class 'mlky.configs.sect.Sect'&gt; .b\n        ```\n        One caveat: on Var objects this works fine, but on Sect objects this\n        is read-only due to creating a view of internal attributes rather than\n        be the attribute variables themselves\n        \"\"\"\n        return self\n\n    @property\n    def _offset(self):\n        \"\"\"\n        Offset in spaces to denote hierarchical level\n        \"\"\"\n        name = len(self.name.split('.'))\n        if isinstance(self.key, int):\n            name += 1\n            key = 1\n        else:\n            key = len(self.key.split('.'))\n\n        return '  ' * (name - key)\n\n    def _debug(self, level, func, msg):\n        \"\"\"\n        Formats debug messages\n        \"\"\"\n        if level in self.debug or func in self.debug:\n            Logger.debug(f'{self._offset}&lt;{type(self).__name__}&gt;({self.name}).{func}() {msg}')\n\n    def _update(self, key, parent):\n        \"\"\"\n        Updates values of this Var given a new parent Sect\n        \"\"\"\n        self.debug = parent._dbug\n\n        if key != self.key:\n            self._debug(1, 'update', f'Updating key from {self.key!r} to {key}')\n            self.key = key\n\n        old = self.name\n        new = parent._subkey(key)\n        if new is not Null and new != old:\n            self._debug(1, '_update', f'Updating name from {old!r} to {new}')\n            self.name = new\n\n        self.parent = parent\n\n    def toDict(self):\n        return self.__dict__\n\n    def deepCopy(self, memo=None):\n        return copy.deepcopy(self, memo)\n\n    def checkType(self, value=Null):\n        \"\"\"\n        Checks a given value against the type set for this object.\n        \"\"\"\n        if value is Null:\n            value = self.value\n\n        # Not required, already a null value (either set in config explicitly as null or was inherently null)\n        if not self.required and value is Null:\n            return True\n\n        return funcs.getRegister('check_dtype')(value, self.dtype)\n\n    def validate(self, value=Null):\n        \"\"\"\n        Validates a value against this variable's checks\n\n        Parameters\n        ----------\n        value: any, defaults=Null\n            Value to validate. If left as default Null, will use the Var.value\n\n        Returns\n        -------\n        errors: mlky.Errors or True\n            If all checks pass, returns True, otherwise returns an Errors\n            object. Essentially the same as a dict. Each key is the check name\n            and the value is either True for passing, a string for a single\n            failure, or a list of strings for multiple failures. This is a\n            custom dict that implements the reduce() function that will only\n            return checks that failed by removing any checks wasn't a str or\n            list. This should help filter bad returns from custom check\n            functions as well.\n        \"\"\"\n        if value is Null:\n            value = self.value\n\n        # Custom dict, can use e.reduce() to remove e[check]=True\n        errors = ErrorsDict()\n\n        # Don't run any checks if the key was missing\n        if self.missing:\n            if self.required:\n                errors['required'] = 'This key is required to be manually set in the config'\n            self._debug(0, 'validate', f'This Var is missing and not required')\n            return errors\n\n        # Check the type before anything else\n        errors['type'] = self.checkType()\n\n        for check in self.checks:\n            args   = []\n            kwargs = {}\n            if isinstance(check, dict):\n                (check, args), = list(check.items())\n                if isinstance(args, dict):\n                    kwargs = args\n                    args = []\n\n            errors[check] = funcs.getRegister(check)(self, *args, **kwargs)\n\n        # self._debug(0, 'validate', f'Errors reduced: {errors.reduce()}') # Very spammy, unsure about usefulness\n        return errors\n\n    def reset(self):\n        \"\"\"\n        Resets this Var's value to its original. This is primarily useful to\n        reset all Vars to trigger replacements after a Config finishes\n        initialization\n        \"\"\"\n        if self.value is not self.original:\n            self._debug(0, 'reset', f'Resetting from {self.value} to {self.original}')\n            self.value = self.original\n\n    def applyDefinition(self, defs):\n        \"\"\"\n        Applies values from a definitions object\n        \"\"\"\n        for key, val in defs.items():\n            self._debug(0, 'applyDefinition', f'{key} = {val!r}')\n            setattr(self, key, val)\n\n    def replace(self, value):\n        \"\"\"\n        mlky replacement magic to support independent Sect instances\n\n        Work in progress\n        \"\"\"\n        # Find the root parent\n        parent = self.parent\n        while parent._prnt:\n            parent = parent._prnt\n\n        # TODO: This is broken, just default to the global instance until further research\n        parent = None\n\n        replacement = funcs.getRegister('config.replace')(value, parent)\n        if replacement is not value:\n            self._debug(0, 'replace', f'Replacing {value!r} with {replacement!r}')\n            return replacement\n</code></pre>"},{"location":"api/var/#mlky.Var.__init__","title":"<code>__init__(name, key, value=Null, default=Null, dtype=Null, required=False, missing=False, checks=[], debug=-1, sdesc='', ldesc='', parent=Null, replace=True)</code>","text":"<p>Variable container object</p>"},{"location":"api/var/#mlky.Var.__init__--parameters","title":"Parameters","text":"<p>replace: bool, defaults=True     Use the default Var.setattr which will call replace() on <code>value</code>     If <code>False</code>, circumvents Var.setattr by using super().setattr</p> Source code in <code>mlky/configs/var.py</code> <pre><code>def __init__(self, name, key,\n    value    = Null,\n    default  = Null,\n    dtype    = Null,\n    required = False,\n    missing  = False,\n    checks   = [],\n    debug    = -1,\n    sdesc    = '',\n    ldesc    = '',\n    parent   = Null,\n    replace  = True\n):\n    \"\"\"\n    Variable container object\n\n    Parameters\n    ----------\n    replace: bool, defaults=True\n        Use the default Var.__setattr__ which will call replace() on `value`\n        If `False`, circumvents Var.__setattr__ by using super().__setattr__\n    \"\"\"\n    if isinstance(debug, int):\n        debug = range(0, debug+1)\n\n    self.name     = name\n    self.key      = key\n    self.default  = default\n    self.dtype    = dtype\n    self.required = required\n    self.missing  = missing\n    self.checks   = checks\n    self.debug    = set(debug)\n    self.sdesc    = sdesc\n    self.ldesc    = ldesc\n    self.parent   = parent\n    self.original = value\n\n    if replace:\n        # This will call replace() then validate()\n        self.value = value\n    else:\n        # No replace(), takes as-is\n        super().__setattr__('value', value)\n</code></pre>"},{"location":"api/var/#mlky.Var.__setattr__","title":"<code>__setattr__(key, value)</code>","text":"Source code in <code>mlky/configs/var.py</code> <pre><code>def __setattr__(self, key, value):\n    \"\"\"\n    \"\"\"\n    if key == 'value':\n        # Lists to Sects disabled, perform a deep replacement\n        if isinstance(value, (list, tuple)):\n            self.original = copy.deepcopy(value)\n            self.deepReplace(value)\n        else:\n            # Always call to see if this value should be replaced\n            new = self.replace(value)\n            if new is not None:\n                self.original = value\n                value = new\n\n        # No longer missing if it's set\n        self.missing = False\n\n        # Non-empty dict means errors found\n        if self.validate(value).reduce():\n            Logger.error(f'Changing the value of this Var({self.name}) will cause validation to fail. See var.validate() for errors.')\n\n    super().__setattr__(key, value)\n</code></pre>"},{"location":"api/var/#mlky.Var.applyDefinition","title":"<code>applyDefinition(defs)</code>","text":"<p>Applies values from a definitions object</p> Source code in <code>mlky/configs/var.py</code> <pre><code>def applyDefinition(self, defs):\n    \"\"\"\n    Applies values from a definitions object\n    \"\"\"\n    for key, val in defs.items():\n        self._debug(0, 'applyDefinition', f'{key} = {val!r}')\n        setattr(self, key, val)\n</code></pre>"},{"location":"api/var/#mlky.Var.checkType","title":"<code>checkType(value=Null)</code>","text":"<p>Checks a given value against the type set for this object.</p> Source code in <code>mlky/configs/var.py</code> <pre><code>def checkType(self, value=Null):\n    \"\"\"\n    Checks a given value against the type set for this object.\n    \"\"\"\n    if value is Null:\n        value = self.value\n\n    # Not required, already a null value (either set in config explicitly as null or was inherently null)\n    if not self.required and value is Null:\n        return True\n\n    return funcs.getRegister('check_dtype')(value, self.dtype)\n</code></pre>"},{"location":"api/var/#mlky.Var.deepReplace","title":"<code>deepReplace(value)</code>","text":"<p>Calls reset on the children of this Var's value if it is a list type</p> Source code in <code>mlky/configs/var.py</code> <pre><code>def deepReplace(self, value):\n    \"\"\"\n    Calls reset on the children of this Var's value if it is a list type\n    \"\"\"\n    for i, item in enumerate(value):\n        if 'Sect' in str(type(item)):\n            self._debug(2, 'deepReplace', f'Resetting {item}')\n            item.resetVars()\n\n        elif isinstance(item, str):\n            new = self.replace(item)\n            if new is not None:\n                self._debug(2, 'deepReplace', f'Replacing index [{i}] {item!r} with {new!r}')\n                value[i] = new\n\n        elif isinstance(item, (list, tuple)):\n            self._debug(2, 'deepReplace', f'Calling deepReplace on child list {item}')\n            self.deepReplace(item)\n</code></pre>"},{"location":"api/var/#mlky.Var.replace","title":"<code>replace(value)</code>","text":"<p>mlky replacement magic to support independent Sect instances</p> <p>Work in progress</p> Source code in <code>mlky/configs/var.py</code> <pre><code>def replace(self, value):\n    \"\"\"\n    mlky replacement magic to support independent Sect instances\n\n    Work in progress\n    \"\"\"\n    # Find the root parent\n    parent = self.parent\n    while parent._prnt:\n        parent = parent._prnt\n\n    # TODO: This is broken, just default to the global instance until further research\n    parent = None\n\n    replacement = funcs.getRegister('config.replace')(value, parent)\n    if replacement is not value:\n        self._debug(0, 'replace', f'Replacing {value!r} with {replacement!r}')\n        return replacement\n</code></pre>"},{"location":"api/var/#mlky.Var.reset","title":"<code>reset()</code>","text":"<p>Resets this Var's value to its original. This is primarily useful to reset all Vars to trigger replacements after a Config finishes initialization</p> Source code in <code>mlky/configs/var.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Resets this Var's value to its original. This is primarily useful to\n    reset all Vars to trigger replacements after a Config finishes\n    initialization\n    \"\"\"\n    if self.value is not self.original:\n        self._debug(0, 'reset', f'Resetting from {self.value} to {self.original}')\n        self.value = self.original\n</code></pre>"},{"location":"api/var/#mlky.Var.validate","title":"<code>validate(value=Null)</code>","text":"<p>Validates a value against this variable's checks</p>"},{"location":"api/var/#mlky.Var.validate--parameters","title":"Parameters","text":"<p>value: any, defaults=Null     Value to validate. If left as default Null, will use the Var.value</p>"},{"location":"api/var/#mlky.Var.validate--returns","title":"Returns","text":"<p>errors: mlky.Errors or True     If all checks pass, returns True, otherwise returns an Errors     object. Essentially the same as a dict. Each key is the check name     and the value is either True for passing, a string for a single     failure, or a list of strings for multiple failures. This is a     custom dict that implements the reduce() function that will only     return checks that failed by removing any checks wasn't a str or     list. This should help filter bad returns from custom check     functions as well.</p> Source code in <code>mlky/configs/var.py</code> <pre><code>def validate(self, value=Null):\n    \"\"\"\n    Validates a value against this variable's checks\n\n    Parameters\n    ----------\n    value: any, defaults=Null\n        Value to validate. If left as default Null, will use the Var.value\n\n    Returns\n    -------\n    errors: mlky.Errors or True\n        If all checks pass, returns True, otherwise returns an Errors\n        object. Essentially the same as a dict. Each key is the check name\n        and the value is either True for passing, a string for a single\n        failure, or a list of strings for multiple failures. This is a\n        custom dict that implements the reduce() function that will only\n        return checks that failed by removing any checks wasn't a str or\n        list. This should help filter bad returns from custom check\n        functions as well.\n    \"\"\"\n    if value is Null:\n        value = self.value\n\n    # Custom dict, can use e.reduce() to remove e[check]=True\n    errors = ErrorsDict()\n\n    # Don't run any checks if the key was missing\n    if self.missing:\n        if self.required:\n            errors['required'] = 'This key is required to be manually set in the config'\n        self._debug(0, 'validate', f'This Var is missing and not required')\n        return errors\n\n    # Check the type before anything else\n    errors['type'] = self.checkType()\n\n    for check in self.checks:\n        args   = []\n        kwargs = {}\n        if isinstance(check, dict):\n            (check, args), = list(check.items())\n            if isinstance(args, dict):\n                kwargs = args\n                args = []\n\n        errors[check] = funcs.getRegister(check)(self, *args, **kwargs)\n\n    # self._debug(0, 'validate', f'Errors reduced: {errors.reduce()}') # Very spammy, unsure about usefulness\n    return errors\n</code></pre>"}]}