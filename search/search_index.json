{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mlky Because it's the only Way. What is mlky? mlky is a versatile Python configuration software package designed by data scientists at the Jet Propulsion Laboratory to cater to the needs of research projects and machine learning pipelines. Originally conceived as a collection of utility scripts and functions, mlky has evolved into a comprehensive configuration package that prioritizes flexibility, robustness, and scalability. Features Configuration Patching : The core of mlky is the patching structure that enables configuration sections to patch from others. This empowers users to craft intricate configuration setups, overriding keys, subkeys, and updating values as needed. Forgiving or Restrictive : mlky imposes minimal requirements right out of the box. With the custom-built Null class, mlky avoids raising exceptions when pieces of the configuration are absent. This allows developers to focus on developing their code and less on developing their configuration structures. However, mlky also provides the tools for developers to restrict exactly what configurations consist of. The flexibility of your configuration is for you to define! Customizable Restriction : While flexibility is paramount, mlky uniquely provides developers the ability to enforce restrictions on a per-key basis. Error-checking, type-checking, type-coercion, and custom parse functions are supported, enabling fine-grained control over configuration options. TRL Scalability : mlky is designed to assist projects scaling the Technology Readiness Levels ( TRL ). At low-TRLs, mlky offers its maximum flexibility by providing minimal setup, simple syntax, and forgiving fault tolerance. Once time for a project to mature, mlky assists achieving higher TRLs by providing the framework to set rigid configuration requirements, template generation, and custom error checking. Contributing We welcome contributions from the community. If you'd like to contribute to mlky, please follow these steps: Fork the repository and clone it locally. Create a new branch for your feature or bug fix. Make your changes and ensure tests pass. Commit your changes and push them to your fork. Open a pull request with a detailed description of your changes. License mlky is distributed under the Apache v2.0 License . Feel free to use, modify, and distribute it according to the terms of the license. Explore the power of flexible and robust configuration with mlky, the configuration package built by data scientists, for data scientists. Whether you're working on a small project or a complex system, mlky adapts to your needs and helps you streamline your configuration process.","title":"Home"},{"location":"#mlky","text":"Because it's the only Way.","title":"mlky"},{"location":"#what-is-mlky","text":"mlky is a versatile Python configuration software package designed by data scientists at the Jet Propulsion Laboratory to cater to the needs of research projects and machine learning pipelines. Originally conceived as a collection of utility scripts and functions, mlky has evolved into a comprehensive configuration package that prioritizes flexibility, robustness, and scalability.","title":"What is mlky?"},{"location":"#features","text":"Configuration Patching : The core of mlky is the patching structure that enables configuration sections to patch from others. This empowers users to craft intricate configuration setups, overriding keys, subkeys, and updating values as needed. Forgiving or Restrictive : mlky imposes minimal requirements right out of the box. With the custom-built Null class, mlky avoids raising exceptions when pieces of the configuration are absent. This allows developers to focus on developing their code and less on developing their configuration structures. However, mlky also provides the tools for developers to restrict exactly what configurations consist of. The flexibility of your configuration is for you to define! Customizable Restriction : While flexibility is paramount, mlky uniquely provides developers the ability to enforce restrictions on a per-key basis. Error-checking, type-checking, type-coercion, and custom parse functions are supported, enabling fine-grained control over configuration options. TRL Scalability : mlky is designed to assist projects scaling the Technology Readiness Levels ( TRL ). At low-TRLs, mlky offers its maximum flexibility by providing minimal setup, simple syntax, and forgiving fault tolerance. Once time for a project to mature, mlky assists achieving higher TRLs by providing the framework to set rigid configuration requirements, template generation, and custom error checking.","title":"Features"},{"location":"#contributing","text":"We welcome contributions from the community. If you'd like to contribute to mlky, please follow these steps: Fork the repository and clone it locally. Create a new branch for your feature or bug fix. Make your changes and ensure tests pass. Commit your changes and push them to your fork. Open a pull request with a detailed description of your changes.","title":"Contributing"},{"location":"#license","text":"mlky is distributed under the Apache v2.0 License . Feel free to use, modify, and distribute it according to the terms of the license. Explore the power of flexible and robust configuration with mlky, the configuration package built by data scientists, for data scientists. Whether you're working on a small project or a complex system, mlky adapts to your needs and helps you streamline your configuration process.","title":"License"},{"location":"defs/","text":"Definitions Definition files (shorthand: defs ) are structured YAML documents designed to guide a Sect (which Config is a subclass of) object in populating itself and enforcing validation rules. Population Process : When processing a configuration input, a Sect object generates child keys (of type Sect or Var ) based on the definitions provided in the defs.yml . If a key is missing in the input but defined in the defs.yml , it will be added with default values. Rule Enforcement : Rules specified in defs.yml are applied to the respective key objects within the Sect . For example, if a key like A is defined with a data type of int , attempting to assign any other data type to A will result in a validation failure triggered by Sect.validate() . Various types of rules, such as isfile , isbetween(val1, val2) , are supported, alongside the ability to incorporate custom rule functions, known as checks . How to Construct Root Level defs.yml files are structured to start from the root level of the Sect object. In patch-less instantiations, the root level is the top level of the input. In patched instantiations, the root level is the next level down. For example: A : m : ... B : n : ... The above input config patch-less Sect(config) will produce: A : m : ... B : n : ... The root level in this case is A, B , so the defs should start with defining these keys. Whereas using a patch Sect(data=config, patch=\"A<-B\") : m : ... n : ... The root is m, n , and as such defs will start with these instead. Keys A key of the config starts with a period . followed by the name of the key. Definition options do not start with a period . . Assume this is a defs.yml : .train : default : abc .test : default : xyz And a potential config.yml : default : train : ijk mno : test : mno uvw : test : uvw override : train : \\ Possible instantiations: Use only the default section, pulling the train from the defs >>> Sect ( data = 'config.yml' , defs = 'defs.yml' , patch = [ 'default' ]) train : ijk test : xyz Patch section mno onto default , aka default<-mno >>> Sect ( data = 'config.yml' , defs = 'defs.yml' , patch = [ 'default' , 'mno' ]) train : ijk test : mno Use the default value of train as set by the defs instead of the default section >>> Sect ( data = 'config.yml' , defs = 'defs.yml' , patch = [ 'default' , 'override' ]) train : abc test : xyz Now patch the test key with the uvw section but use the default value of train from defs >>> Sect ( data = 'config.yml' , defs = 'defs.yml' , patch = [ 'override' , 'uvw' ]) train : abc test : uvw Var keys Var are container objects for keys that are any type other than dict or list (unless Sect._opts.convertListTypes is set to False ). The options for a Var key are as follows: Option Description Example dtype The expected data type. This can either be a single type or a list of types dtype: int dtype: [str, int] sdesc Short description for the key sdesc: This describes what the key is for ldesc Long description for the key ldesc: This is to be an extra long description default Default value to set when not provided. Omit to default to Null default: 1 default: abc required Boolean setting this key to be required to be set by the user manually required: true required: false checks Registered checks to apply to the key See the checks section for more information and examples items When the Var is a list type with dict items, this sets the definition for each child See the items section for more information and examples subtypes See the items section for more information and examples Var Items Var Subtypes subtypes is a special option for Vars that define different types for a given key. Sect keys Sect objects can either be explicitly or implicitly defined. To do so explicitly, set dtype: dict . Implicitly, if any child key is detected (by checking if any subkey starts with a period), then the dtype is set automatically. .model: .kind: dtype: str default: RandomForestRegressor .params: dtype: dict The above will be detected to be a Sect on creation. Rules / Checks Rules applied via the defs are known as checks . They are executed when the .validate() function is called on either a Sect or Var object. Var Checks ... Sect Checks","title":"Definitions"},{"location":"defs/#definitions","text":"Definition files (shorthand: defs ) are structured YAML documents designed to guide a Sect (which Config is a subclass of) object in populating itself and enforcing validation rules. Population Process : When processing a configuration input, a Sect object generates child keys (of type Sect or Var ) based on the definitions provided in the defs.yml . If a key is missing in the input but defined in the defs.yml , it will be added with default values. Rule Enforcement : Rules specified in defs.yml are applied to the respective key objects within the Sect . For example, if a key like A is defined with a data type of int , attempting to assign any other data type to A will result in a validation failure triggered by Sect.validate() . Various types of rules, such as isfile , isbetween(val1, val2) , are supported, alongside the ability to incorporate custom rule functions, known as checks .","title":"Definitions"},{"location":"defs/#how-to-construct","text":"","title":"How to Construct"},{"location":"defs/#root-level","text":"defs.yml files are structured to start from the root level of the Sect object. In patch-less instantiations, the root level is the top level of the input. In patched instantiations, the root level is the next level down. For example: A : m : ... B : n : ... The above input config patch-less Sect(config) will produce: A : m : ... B : n : ... The root level in this case is A, B , so the defs should start with defining these keys. Whereas using a patch Sect(data=config, patch=\"A<-B\") : m : ... n : ... The root is m, n , and as such defs will start with these instead.","title":"Root Level"},{"location":"defs/#keys","text":"A key of the config starts with a period . followed by the name of the key. Definition options do not start with a period . . Assume this is a defs.yml : .train : default : abc .test : default : xyz And a potential config.yml : default : train : ijk mno : test : mno uvw : test : uvw override : train : \\ Possible instantiations: Use only the default section, pulling the train from the defs >>> Sect ( data = 'config.yml' , defs = 'defs.yml' , patch = [ 'default' ]) train : ijk test : xyz Patch section mno onto default , aka default<-mno >>> Sect ( data = 'config.yml' , defs = 'defs.yml' , patch = [ 'default' , 'mno' ]) train : ijk test : mno Use the default value of train as set by the defs instead of the default section >>> Sect ( data = 'config.yml' , defs = 'defs.yml' , patch = [ 'default' , 'override' ]) train : abc test : xyz Now patch the test key with the uvw section but use the default value of train from defs >>> Sect ( data = 'config.yml' , defs = 'defs.yml' , patch = [ 'override' , 'uvw' ]) train : abc test : uvw","title":"Keys"},{"location":"defs/#var-keys","text":"Var are container objects for keys that are any type other than dict or list (unless Sect._opts.convertListTypes is set to False ). The options for a Var key are as follows: Option Description Example dtype The expected data type. This can either be a single type or a list of types dtype: int dtype: [str, int] sdesc Short description for the key sdesc: This describes what the key is for ldesc Long description for the key ldesc: This is to be an extra long description default Default value to set when not provided. Omit to default to Null default: 1 default: abc required Boolean setting this key to be required to be set by the user manually required: true required: false checks Registered checks to apply to the key See the checks section for more information and examples items When the Var is a list type with dict items, this sets the definition for each child See the items section for more information and examples subtypes See the items section for more information and examples","title":"Var keys"},{"location":"defs/#var-items","text":"","title":"Var Items"},{"location":"defs/#var-subtypes","text":"subtypes is a special option for Vars that define different types for a given key.","title":"Var Subtypes"},{"location":"defs/#sect-keys","text":"Sect objects can either be explicitly or implicitly defined. To do so explicitly, set dtype: dict . Implicitly, if any child key is detected (by checking if any subkey starts with a period), then the dtype is set automatically. .model: .kind: dtype: str default: RandomForestRegressor .params: dtype: dict The above will be detected to be a Sect on creation.","title":"Sect keys"},{"location":"defs/#rules-checks","text":"Rules applied via the defs are known as checks . They are executed when the .validate() function is called on either a Sect or Var object.","title":"Rules / Checks"},{"location":"defs/#var-checks","text":"...","title":"Var Checks"},{"location":"defs/#sect-checks","text":"","title":"Sect Checks"},{"location":"usage/","text":"Getting Started mlky is recommended to be installed via pip at this time. Installation You can install mlky using pip: pip install mlky Or via Conda: conda install -c jammont mlky Quick Overview To get started with mlky, import the Config object and pass it either a yaml file, yaml string, or a dict: >>> from mlky import Config >>> # Empty initially >>> Config D {} >>> # Now initialized >>> Config ({ 'A' : { 'a' : 1 , 'b' : 2 }, 'B' : { 'a' : 0 , 'c' : 3 }, 'C' : [ 'd' , 'e' ]}) D { 'A' : D { 'a' : V = 1 , 'b' : V = 2 }, 'B' : D { 'a' : V = 0 , 'c' : V = 3 }, 'C' : L [ V = 'd' , V = 'e' ]} The object uses tags to represent what each part is: D{...} for dict objects L[...] for list objects V=... for variable objects These can be accessed by either dot and dict notation: >>> Config . A D { 'a' : V = 1 , 'b' : V = 2 } >>> Config [ 'B' ] D { 'a' : V = 0 , 'c' : V = 3 } >>> Config . A . a 1 >>> Config [ 'B' ][ 'a' ] 0 >>> Config [ 'A' ] . b 2 >>> Config . B [ 'c' ] 3 The Config object is also a singleton, though copies can be created to create local versions: def set_param ( key , value , copy = False ): if copy : config = Config . deepCopy () else : config = Config () config [ key ] = value def get_param ( key , copy = False ): if copy : config = Config . deepCopy () else : config = Config () return config [ key ] >>> set_param ( 'persist' , True ) # Global >>> get_param ( 'persist' ) # Global True >>> set_param ( 'local' , True , copy = True ) >>> get_param ( 'local' ) Null >>> get_param ( 'persist' , copy = True ) # Copies global instance True Because it is a singleton, you can also use Config directly instead of a variable as well as use the object across the Python instance: # Script 1 from mlky import Config Config ( a = 1 , b = 2 ) # initialize somewhere # Script 2 from mlky import Config assert Config . a == 1 assert Config . b == 2 Ideally you would want to initialize the Config object at the beginning and then leverage the global instance: from mlky import Config def process ( item ): if Config . param : ... def main (): for item in Config . process : process ( item ) if __name__ == '__main__' : Config ( '/some/config.yaml' ) main () Detailed Walkthrough The following will be used as an example: from glob import glob from mlky import Config def process ( files ): for file in files : with open ( file , 'r' ) as f : lines = f . readlines () if Config . skip_header : lines = lines [ Config . header :] ... # Some arbitrary other processing code if Config . output : with open ( Config . output . file , 'a' ) as f : f . writelines ( lines ) if __name__ == '__main__' : parser = argparse . ArgumentParser () parser . add_argument ( '-c' , '--config' , required = True ) parser . add_argument ( '-p' , '--patch' ) args = parser . parse_args () Config ( args . config , args . patch ) if Config . get ( 'input' ): files = glob ( f ' { Config . input } /*' ) process ( files ) else : print ( 'Error: No input provided!' ) Command: python script.py -c /some/config.yml -p \"sect1<-sect2\" Calling the script with the above command will step through: Initialize the global Config instance with the file and patch provided a. That is, sect1 in the config.yml will be patched with sect2 Check if Config.input exists a. If it is in the Config, return it as-is. If it is not, this will be a Null value which evaluates to False Use the value at Config.input to glob some directory Process the collected files For each file, read in the data If Config.skip_header is defined, use the (expected to be an int) value of Config.header a. It is on the user to ensure proper safeguards are inplace. b. Multiple possible safeguards include: int(Config.header) to raise an exception if the value cannot be casted to an integer Config.get('header', 5) to use a default value if this key is not in the config A definitions file to ensure this key is an int (safest) Check if Config.output is defined, which is expected to be a Sect Append write data to Config.output.file","title":"Getting Started"},{"location":"usage/#getting-started","text":"mlky is recommended to be installed via pip at this time.","title":"Getting Started"},{"location":"usage/#installation","text":"You can install mlky using pip: pip install mlky Or via Conda: conda install -c jammont mlky","title":"Installation"},{"location":"usage/#quick-overview","text":"To get started with mlky, import the Config object and pass it either a yaml file, yaml string, or a dict: >>> from mlky import Config >>> # Empty initially >>> Config D {} >>> # Now initialized >>> Config ({ 'A' : { 'a' : 1 , 'b' : 2 }, 'B' : { 'a' : 0 , 'c' : 3 }, 'C' : [ 'd' , 'e' ]}) D { 'A' : D { 'a' : V = 1 , 'b' : V = 2 }, 'B' : D { 'a' : V = 0 , 'c' : V = 3 }, 'C' : L [ V = 'd' , V = 'e' ]} The object uses tags to represent what each part is: D{...} for dict objects L[...] for list objects V=... for variable objects These can be accessed by either dot and dict notation: >>> Config . A D { 'a' : V = 1 , 'b' : V = 2 } >>> Config [ 'B' ] D { 'a' : V = 0 , 'c' : V = 3 } >>> Config . A . a 1 >>> Config [ 'B' ][ 'a' ] 0 >>> Config [ 'A' ] . b 2 >>> Config . B [ 'c' ] 3 The Config object is also a singleton, though copies can be created to create local versions: def set_param ( key , value , copy = False ): if copy : config = Config . deepCopy () else : config = Config () config [ key ] = value def get_param ( key , copy = False ): if copy : config = Config . deepCopy () else : config = Config () return config [ key ] >>> set_param ( 'persist' , True ) # Global >>> get_param ( 'persist' ) # Global True >>> set_param ( 'local' , True , copy = True ) >>> get_param ( 'local' ) Null >>> get_param ( 'persist' , copy = True ) # Copies global instance True Because it is a singleton, you can also use Config directly instead of a variable as well as use the object across the Python instance: # Script 1 from mlky import Config Config ( a = 1 , b = 2 ) # initialize somewhere # Script 2 from mlky import Config assert Config . a == 1 assert Config . b == 2 Ideally you would want to initialize the Config object at the beginning and then leverage the global instance: from mlky import Config def process ( item ): if Config . param : ... def main (): for item in Config . process : process ( item ) if __name__ == '__main__' : Config ( '/some/config.yaml' ) main ()","title":"Quick Overview"},{"location":"usage/#detailed-walkthrough","text":"The following will be used as an example: from glob import glob from mlky import Config def process ( files ): for file in files : with open ( file , 'r' ) as f : lines = f . readlines () if Config . skip_header : lines = lines [ Config . header :] ... # Some arbitrary other processing code if Config . output : with open ( Config . output . file , 'a' ) as f : f . writelines ( lines ) if __name__ == '__main__' : parser = argparse . ArgumentParser () parser . add_argument ( '-c' , '--config' , required = True ) parser . add_argument ( '-p' , '--patch' ) args = parser . parse_args () Config ( args . config , args . patch ) if Config . get ( 'input' ): files = glob ( f ' { Config . input } /*' ) process ( files ) else : print ( 'Error: No input provided!' ) Command: python script.py -c /some/config.yml -p \"sect1<-sect2\" Calling the script with the above command will step through: Initialize the global Config instance with the file and patch provided a. That is, sect1 in the config.yml will be patched with sect2 Check if Config.input exists a. If it is in the Config, return it as-is. If it is not, this will be a Null value which evaluates to False Use the value at Config.input to glob some directory Process the collected files For each file, read in the data If Config.skip_header is defined, use the (expected to be an int) value of Config.header a. It is on the user to ensure proper safeguards are inplace. b. Multiple possible safeguards include: int(Config.header) to raise an exception if the value cannot be casted to an integer Config.get('header', 5) to use a default value if this key is not in the config A definitions file to ensure this key is an int (safest) Check if Config.output is defined, which is expected to be a Sect Append write data to Config.output.file","title":"Detailed Walkthrough"}]}